I l@ve RuBoard Front Matter Table of Contents About the Author Pragmatic Programmer, The: From Journeyman to Master Andrew HuntDavid ThomasPublisher: Addison WesleyFirst Edition October 13, 1999ISBN: 0-201-61622-X, 352 pages Straight from the programming trenches, The Pragmatic Programmer cuts through the increasingspecialization and technicalities of modern software development to examine the core process--takinga requirement and producing working, maintainable code that delights its users. It covers topicsranging from personal responsibility and career development to architectural techniques for keepingyour code flexible and easy to adapt and reuse. Read this book, and youll learn how to:Fight software rot;Avoid the trap of duplicating knowledge;Write flexible, dynamic, and adaptable code;Avoid programming by coincidence;Bullet-proof your code with contracts, assertions, and exceptions; Capture real requirements;Test ruthlessly and effectively;Delight your users;Build teams of pragmatic programmers; andMake your developments more precise with automation.Written as a series of self-contained sections and filled with entertaining anecdotes, thoughtful examples, and interesting analogies, The Pragmatic Programmer illustrates the best practices andmajor pitfalls of many different aspects of software development. Whether youre a new coder, anexperienced programmer, or a manager responsible for software projects, use these lessons daily,and youll quickly see improvements in personal productivity, accuracy, and job satisfaction. Youlllearn skills and develop habits and attitudes that form the foundation for long-term success in yourcareer. Youll become a Pragmatic Programmer.I l@ve RuBoard  I l@ve RuBoard   Pragmatic Programmer, The: From Journeyman to Master Foreword Preface    Who Should Read This Book?    What Makes a Pragmatic Programmer?    Individual Pragmatists, Large Teams    It's a Continuous Process    How the Book Is Organized    What's in a Name? 1. A Pragmatic Philosophy    The Cat Ate My Source Code    Software Entropy    Stone Soup and Boiled Frogs    Good-Enough Software    Your Knowledge Portfolio    Communicate!    Summary 2. A Pragmatic Approach    The Evils of Duplication    Orthogonality    Reversibility    Tracer Bullets    Prototypes and Post-it Notes    Domain Languages    Estimating 3. The Basic Tools    The Power of Plain Text     Shell Games    Power Editing    Source Code Control    But My Team Isn't Using Source Code Control    Source Code Control Products    Debugging    Text Manipulation    Exercises    Code Generators 4. Pragmatic Paranoia    Design by Contract    Dead Programs Tell No Lies    Assertive Programming    When to Use Exceptions    How to Balance Resources    Objects and Exceptions    Balancing and Exceptions    When You Can't Balance Resources    Checking the Balance    Exercises 5. Bend or Break    Decoupling and the Law of Demeter    Metaprogramming    Temporal Coupling    It's Just a View    Blackboards 6. While You Are Coding    Programming by Coincidence    Algorithm Speed    Refactoring    Code That's Easy to Test    Evil Wizards 7. Before the Project    The Requirements Pit    Solving Impossible Puzzles    Not Until You're Ready    The Specification Trap    Circles and Arrows 8. Pragmatic Projects    Pragmatic Teams    Ubiquitous Automation     Ruthless Testing    It's All Writing    Great Expectations    Pride and Prejudice A. Resources    Professional Societies    Building a Library    Internet Resources    Bibliography B. Answers to Exercises I l@ve RuBoard    I l@ve RuBoard   Pragmatic Programmer, The: From Journeyman to Master Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this book, and Addison-Wesley was aware of a trademark claim, the designations have been printed in initial capital letters or in all capitals.Lyrics from the song "The Boxer" on page 157 are Copyright © 1968 PaulSimon. Used by permission of the Publisher: Paul Simon Music. Lyrics from the song "Alice's Restaurant" on page 220 are by Arlo Guthrie, ©1966,1967 (renewed) by Appleseed Music Inc. All Rights Reserved. Used by Permission.The authors and publisher have taken care in the preparation of this book, but make no express or implied warranty of any kind and assume no responsibility for errors or omissions. No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein.The publisher offers discounts on this book when ordered in quantity for special sales. For more information, please contact:AWL Direct SalesAddison Wesley Longman, Inc.One Jacob WayReading, Massachusetts 01867 (781) 944-3700Visit AWL on the Web: http://www.awl.com/cseng Library of Congress Catalogtng-in-Publication DataHunt, Andrew, 1964The Pragmatic Programmer / Andrew Hunt, David Thomas.p. cm.Includes bibliographical references.ISBN 0-201-61622-X1. Computer programming. I. Thomas, David, 1956 .II. Title.QA76.6.H857 1999005.1--dc21 9943581CIPCopyright © 2000 by Addison Wesley Longman, Inc.All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by any means, electronic, mechanical, photocopying, recording, or otherwise, without the prior written permission of the publisher. Printed in the United States of America. Published simultaneously in Canada.3 4 5 6 7 8 9 10CRS03020100Third printing, October 2000For Ellie and Juliet,Elizabeth and Zachay, Stuart and HenryI l@ve RuBoard    I l@ve RuBoard   ForewordAs a reviewer I got an early opportunity to read the book you are holding. It was great, even in draft form. Dave Thomas and Andy Hunt have something to say, and they know how to say it. I saw what they were doing and I knew it would work. I asked to write this foreword so that I could explain why.Simply put, this book tells you how to program in a way that you can follow. You wouldn't think that that would be a hard thing to do, but it is. Why? For one thing, not all programming books are written by programmers. Many are compiled by language designers, or the journalists who work with them to promote their creations. Those books tell you how to talk in a programming languagewhich is certainly important, but that isonly a small part of what a programmer does.What does a programmer do besides talk in programming language? Well, that is a deeper issue. Most programmers would have trouble explaining what they do. Programming is a job filled with details, and keeping track of those details requires focus. Hours drift by and the code appears. You look up and there are all of those statements. If you don't think carefully, you might think that programming is just typing statements in a programming language. You would be wrong, of course, but you wouldn't be able to tell by looking around the programming section of the bookstore.In The Pragmatic Programmer Dave and Andy tell us how to program in a way that wecan follow. How did they get so smart? Aren't they just as focused on details as otherprogrammers? The answer is that they paid attention to what they were doing while theywere doing itand then they tried to do it better.Imagine that you are sitting in a meeting. Maybe you are thinking that the meeting could go on forever and that you would rather be programming. Dave and Andy would be thinking about why they were having the meeting, and wondering if there is something else they could do that would take the place of the meeting, and deciding if that something could be automated so that the work of the meeting just happens in the future. Then they would do it.That is just the way Dave and Andy think. That meeting wasn't something keeping them from programming. It was programming. And it was programming that could be improved. I know they think this way because it is tip number two: Think About Your Work. So imagine that these guys are thinking this way for a few years. Pretty soon they would have a collection of solutions. Now imagine them using their solutions in their work for a few more years, and discarding the ones that are too hard or don't always produce results. Well, that approach just about defines pragmatic. Now imagine them taking a year or two more to write their solutions down. You might think, That information would be a gold mine. And you would be right.The authors tell us how they program. And they tell us in a way that we can follow. But there is more to this second statement than you might think. Let me explain.The authors have been careful to avoid proposing a theory of software development. This is fortunate, because if they had they would be obliged to warp each chapter to defend their theory. Such warping is the tradition in, say, the physical sciences, where theories eventually become laws or are quietly discarded. Programming on the other hand has few (if any) laws. So programming advice shaped around wanna-be laws may sound good in writing, but it fails to satisfy in practice. This is what goes wrong with so many methodology books.I've studied this problem for a dozen years and found the most promise in a device called a pattern language. In short, a pattern is a solution, and a pattern language is a system of solutions that reinforce each other. A whole community has formed around the search for these systems.This book is more than a collection of tips. It is a pattern language in sheep's clothing. I say that because each tip is drawn from experience, told as concrete advice, and related to others to form a system. These are the characteristics that allow us to learn and follow a pattern language. They work the same way here.You can follow the advice in this book because it is concrete. You won't find vague abstractions. Dave and Andy write directly for you, as if each tip was a vital strategy for energizing your programming career. They make it simple, they tell a story, they use a light touch, and then they follow that up with answers to questions that will come up when you try.And there is more. After you read ten or fifteen tips you will begin to see an extra dimension to the work. We sometimes call it QWAN, short for the quality without a name.The book has a philosophy that will ooze into your consciousness and mix with your own. It doesn't preach. It just tells what works. But in the telling more comes through. That's the beauty of the book: It embodies its philosophy, and it does so unpretentiously. So here it is: an easy to readand usebook about the whole practice of programming.I've gone on and on about why it works. You probably only care that it does work. It does.You will see.Ward CunninghamI l@ve RuBoard    I l@ve RuBoard   PrefaceThis book will help you become a better programmer.It doesn't matter whether you are a lone developer, a member of a large project team, or aconsultant working with many clients at once. This book will help you, as an individual, todo better work. This book isn't theoreticalwe concentrate on practical topics, on usingyour experience to make more informed decisions. The word pragmatic comes from the Latin pragmaticus"skilled in business"which itself is derived from the Greek , meaning "to do." This is a book about doing.Programming is a craft. At its simplest, it comes down to getting a computer to do what you want it to do (or what your user wants it to do). As a programmer, you are part listener, part advisor, part interpreter, and part dictator. You try to capture elusive requirements and find a way of expressing them so that a mere machine can do them justice. You try to document your work so that others can understand it, and you try to engineer your work so that others can build on it. What's more, you try to do all this against the relentless ticking of the project clock. You work small miracles every day.It's a difficult job.There are many people offering you help. Tool vendors tout the miracles their products perform. Methodology gurus promise that their techniques guarantee results. Everyone claims that their programming language is the best, and every operating system is the answer to all conceivable ills.Of course, none of this is true. There are no easy answers. There is no such thing as a best solution, be it a tool, a language, or an operating system. There can only be systems that are more appropriate in a particular set of circumstances.This is where pragmatism comes in. You shouldn't be wedded to any particular technology, but have a broad enough background and experience base to allow you to choose good solutions in particular situations. Your background stems from an understanding of the basic principles of computer science, and your experience comes from a wide range of practical projects. Theory and practice combine to make you strong.You adjust your approach to suit the current circumstances and environment. You judge  the relative importance of all the factors affecting a project and use your experience to produce appropriate solutions. And you do this continuously as the work progresses. Pragmatic Programmers get the job done, and do it well.I l@ve RuBoard    I l@ve RuBoard   Who Should Read This Book?This book is aimed at people who want to become more effective and more productive programmers. Perhaps you feel frustrated that you don't seem to be achieving your potential. Perhaps you look at colleagues who seem to be using tools to make themselves more productive than you. Maybe your current job uses older technologies, and you want to know how newer ideas can be applied to what you do.We don't pretend to have all (or even most) of the answers, nor are all of our ideas applicable in all situations. All we can say is that if you follow our approach, you'll gain experience rapidly, your productivity will increase, and you'll have a better understanding of the entire development process. And you'll write better software.I l@ve RuBoard    I l@ve RuBoard   What Makes a Pragmatic Programmer?Each developer is unique, with individual strengths and weaknesses, preferences and dislikes. Over time, each will craft his or her own personal environment. That environment will reflect the programmer's individuality just as forcefully as his or her hobbies, clothing, or haircut. However, if you're a Pragmatic Programmer, you'll share many of the following characteristics:Early adopter/fast adapter.   You have an instinct for technologies andtechniques, and you love trying things out. When given something new, you can grasp it quickly and integrate it with the rest of your knowledge. Your confidence is born of experience. Inquisitive.   You tend to ask questions. That's neathow did you do that? Didyou have problems with that library? What's this BeOS I've heard about? Howare symbolic links implemented? You are a pack rat for little facts, each of which may affect some decision years from now. Critical thinker.   You rarely take things as given without first getting the facts.When colleagues say "because that's the way it's done," or a vendor promises the solution to all your problems, you smell a challenge. Realistic.   You try to understand the underlying nature of each problem you face.This realism gives you a good feel for how difficult things are, and how long things will take. Understanding for yourself that a process should be difficult or will take a while to complete gives you the stamina to keep at it. Jack of all trades.   You try hard to be familiar with a broad range of technologiesand environments, and you work to keep abreast of new developments. Although your current job may require you to be a specialist, you will always be able to move on to new areas and new challenges. We've left the most basic characteristics until last. All Pragmatic Programmers share them. They're basic enough to state as tips:Tip 1    I l@ve RuBoard   How the Book Is OrganizedThis book is written as a collection of short sections. Each section is self-contained, andaddresses a particular topic. You'll find numerous cross references, which help put eachtopic in context. Feel free to read the sections in any orderthis isn't a book you need toread front-to-back.Occasionally you'll come across a box labeled Tip nn (such as Tip 1, "Care About YourCraft" on page xix). As well as emphasizing points in the text, we feel the tips have a life oftheir ownwe live by them daily. You'll find a summary of all the tips on a pull-out cardinside the back cover.Appendix A  contains a set of resources: the book's bibliography, a list of URLs to Webresources, and a list of recommended periodicals, books, and professional organizations.Throughout the book you'll find references to the bibliography and to the list of URLssuchas [KP99 ] and [URL 18], respectively.We've included exercises and challenges where appropriate. Exercises normally have relatively straightforward answers, while the challenges are more open-ended. To give you an idea of our thinking, we've included our answers to the exercises in Appendix B , but very few have a single correct solution. The challenges might form the basis of group discussions or essay work in advanced programming courses.I l@ve RuBoard     Send Us FeedbackWe'd appreciate hearing from you. Comments, suggestions, errors in the text, and problems in the examples are all welcome. E-mail us atppbook@pragmaticprogrammer.com AcknowledgmentsWhen we started writing this book, we had no idea how much of a team effort it would end up being.Addison-Wesley has been brilliant, taking a couple of wet-behind-the-ears hackers and walking us through the whole book-production process, from idea to camera-ready copy. Many thanks to John Wait and Meera Ravindiran for their initial support, Mike Hendrickson, our enthusiastic editor (and a mean cover designer!), Lorraine Ferrier and John Fuller for their help with production, and the indefatigable Julie DeBaggis for keeping us all together.Then there were the reviewers: Greg Andress, Mark Cheers, Chris Cleeland, Alistair Cockburn, Ward Cunningham, Martin Fowler, Thanh T. Giang, Robert L. Glass, Scott Henninger, Michael Hunter, Brian Kirby, John Lakos, Pete McBreen, Carey P. Morris, Jared Richardson, Kevin Ruland, Eric Starr, Eric Vought, Chris Van Wyk, and Deborra Zukowski. Without their careful comments and valuable insights, this book would be less readable, less accurate, and twice as long. Thank you all for your time and wisdom.The second printing of this book benefited greatly from the eagle eyes of our readers. Many thanks to Brian Blank, Paul Boal, Tom Ekberg, Brent Fulgham, Louis Paul Hebert, Henk-Jan Olde Loohuis, Alan Lund, Gareth McCaughan, Yoshiki Shibata, and Volker Wurst, both for finding the mistakes and for having the grace to point them out gently.Over the years, we have worked with a large number of progressive clients, where we gained and refined the experience we write about here. Recently, we've been fortunate to work with Peter Gehrke on several large projects. His support and enthusiasm for our techniques are much appreciated.This book was produced using LATEX, pic, Perl, dvips, ghostview, ispell, GNU make, CVS, Emacs, XEmacs, EGCS, GCC, Java, iContract, and SmallEiffel, using the Bash and zsh shells under Linux. The staggering thing is that all of this tremendous software is freely available. We owe a huge "thank you" to the thousands of Pragmatic Programmers  worldwide who have contributed these and other works to us all. We'd particularly like to thank Reto Kramer for his help with iContract.Last, but in no way least, we owe a huge debt to our families. Not only have they put up with late night typing, huge telephone bills, and our permanent air of distraction, but they've had the grace to read what we've written, time after time. Thank you for letting us dream.Andy HuntDave ThomasI l@ve RuBoard    I l@ve RuBoard   Chapter 1. A Pragmatic PhilosophyWhat distinguishes Pragmatic Programmers? We feel it's an attitude, a style, a philosophy of approaching problems and their solutions. They think beyond the immediate problem, always trying to place it in its larger context, always trying to be aware of the bigger picture. After all, without this larger context, how can you be pragmatic? How can you make intelligent compromises and informed decisions?Another key to their success is that they take responsibility for everything they do, which we discuss in The Cat Ate My Source Code. Being responsible, Pragmatic Programmers won't sit idly by and watch their projects fall apart through neglect. In Software Entropy, we tell you how to keep your projects pristine.Most people find change difficult to accept, sometimes for good reasons, sometimes because of plain old inertia. In Stone Soup and Boiled Frogs, we look at a strategy for instigating change and (in the interests of balance) present the cautionary tale of an amphibian that ignored the dangers of gradual change.One of the benefits of understanding the context in which you work is that it becomes easier to know just how good your software has to be. Sometimes near-perfection is the only option, but often there are trade-offs involved. We explore this in Good-Enough Software.Of course, you need to have a broad base of knowledge and experience to pull all of this off. Learning is a continuous and ongoing process. In Your Knowledge Portfolio, we discuss some strategies for keeping the momentum up.Finally, none of us works in a vacuum. We all spend a large amount of time interacting with others. Communicate! lists ways we can do this better.Pragmatic programming stems from a philosophy of pragmatic thinking. This chapter sets the basis for that philosophy.I l@ve RuBoard      Ruthless Testing ChallengesHow do you react when someonesuch as a bank teller, an auto mechanic, or aclerkcomes to you with a lame excuse? What do you think of them and theircompany as a result? I l@ve RuBoard     Don't Live with Broken WindowsDon't leave "broken windows" (bad designs, wrong decisions, or poor code) unrepaired. Fix each one as soon as it is discovered. If there is insufficient time to fix it properly, then board it up. Perhaps you can comment out the offending code, or display a "Not Implemented" message, or substitute dummy data instead. Take some action to prevent further damage and to show that you're on top of the situation.We've seen clean, functional systems deteriorate pretty quickly once windows start breaking. There are other factors that can contribute to software rot, and we'll touch on some of them elsewhere, but neglect accelerates the rot faster than any other factor.You may be thinking that no one has the time to go around cleaning up all the broken glass of a project. If you continue to think like that, then you'd better plan on getting a dumpster, or moving to another neighborhood. Don't let entropy win.Putting Out FiresBy contrast, there's the story of an obscenely rich acquaintance of Andy's. His house was immaculate, beautiful, loaded with priceless antiques, objets d'art, and so on. One day, atapestry that was hanging a little too close to his living room fireplace caught on fire. Thefire department rushed in to save the dayand his house. But before they dragged theirbig, dirty hoses into the house, they stoppedwith the fire ragingto roll out a matbetween the front door and the source of the fire.They didn't want to mess up the carpet.A pretty extreme case, to be sure, but that's the way it must be with software. One brokenwindowa badly designed piece of code, a poor management decision that the team mustlive with for the duration of the project is all it takes to start the decline. If you findyourself working on a project with quite a few broken windows, it's all too easy to slip intothe mindset of "All the rest of this code is crap, I'll just follow suit." It doesn't matter if theproject has been fine up to this point. In the original experiment leading to the "BrokenWindow Theory," an abandoned car sat for a week untouched. But once a single windowwas broken, the car was stripped and turned upside down within hours. By the same token, if you find yourself on a team and a project where the code is pristinelybeautifulcleanly written, well designed, and elegantyou will likely take extra specialcare not to mess it up, just like the firefighters. Even if there's a fire raging (deadline,release date, trade show demo, etc.), you don't want to be the first one to make a mess.Related sections include:Stone Soup and Boiled Frogs Refactoring Pragmatic Teams ChallengesHelp strengthen your team by surveying your computing "neighborhood." Choose two or three "broken windows" and discuss with your colleagues what the problems are and what could be done to fix them. Can you tell when a window first gets broken? What is your reaction? If it was the result of someone else's decision, or a management edict, what can you do about it? I l@ve RuBoard      We've never tried thishonest. But they say that if you take a frog and drop it into boilingwater, it will jump straight back out again. However, if you place the frog in a pan of coldwater, then gradually heat it, the frog won't notice the slow increase in temperature and willstay put until cooked.Note that the frog's problem is different from the broken windows issue discussed in Section 2 . In the Broken Window Theory, people lose the will to fight entropy because they perceive that no one else cares. The frog just doesn't notice the change.Don't be like the frog. Keep an eye on the big picture. Constantly review what's happening around you, not just what you personally are doing.Related sections include:Software Entropy Programming by Coincidence Refactoring The Requirements Pit Pragmatic Teams ChallengesWhile reviewing a draft of this book, John Lakos raised the following issue: The soldiers progressively deceive the villagers, but the change they catalyze does them all good. However, by progressively deceiving the frog, you're doing it harm. Can you determine whether you're making stone soup or frog soup when you try to catalyze change? Is the decision subjective or objective? I l@ve RuBoard     your company will certainly have cash-flow constraints. It would be unprofessional to ignore these users' requirements simply to add new features to the program, or to polish up the code just one more time. We're not advocating panic: it is equally unprofessional to promise impossible time scales and to cut basic engineering corners to meet a deadline. [2] That was supposed to be a joke!The scope and quality of the system you produce should be specified as part of that system's requirements.Tip 7Make Quality a Requirements IssueOften you'll be in situations where trade-offs are involved. Surprisingly, many users would rather use software with some rough edges today than wait a year for the multimedia version. Many IT departments with tight budgets would agree. Great software today is often preferable to perfect software tomorrow. If you give your users something to play with early, their feedback will often lead you to a better eventual solution (see Tracer Bullets ).Know When to StopIn some ways, programming is like painting. You start with a blank canvas and certain basic raw materials. You use a combination of science, art, and craft to determine what to do with them. You sketch out an overall shape, paint the underlying environment, then fill in the details. You constantly step back with a critical eye to view what you've done. Every now and then you'll throw a canvas away and start again.But artists will tell you that all the hard work is ruined if you don't know when to stop. If you add layer upon layer, detail over detail, the painting becomes lost in the paint.Don't spoil a perfectly good program by overembellishment and over-refinement. Move on, and let your code stand in its own right for a while. It may not be perfect. Don't worry: it could never be perfect. (In Chapter 6 , we'll discuss philosophies for developing code in an imperfect world.) Related sections include:Tracer Bullets The Requirements Pit Pragmatic Teams Great Expectations ChallengesLook at the manufacturers of the software tools and operating systems that you use. Can you find any evidence that these companies are comfortable shipping software they know is not perfect? As a user, would you rather (1) wait for them to get all the bugs out, (2) have complex software and accept some bugs, or (3) opt for simpler software with fewer defects? Consider the effect of modularization on the delivery of software. Will it take more or less time to get a monolithic block of software to the required quality compared with a system designed in modules? Can you find commercial examples? I l@ve RuBoard    I l@ve RuBoard   Your Knowledge PortfolioAn investment in knowledge always pays the best interest.Benjamin FranklinAh, good old Ben Franklinnever at a loss for a pithy homily. Why, if we could just be earlyto bed and early to rise, we'd be great programmersright? The early bird might get theworm, but what happens to the early worm?In this case, though, Ben really hit the nail on the head. Your knowledge and experience are your most important professional assets.Unfortunately, they're expiring assets.[3]  Your knowledge becomes out of date as newtechniques, languages, and environments are developed. Changing market forces may render your experience obsolete or irrelevant. Given the speed at which Web-years fly by, this can happen pretty quickly. [3] An expiring asset is something whose value diminishes over time. Examples include a warehouse full of bananas and a ticket to a ball game.As the value of your knowledge declines, so does your value to your company or client. Wewant to prevent this from ever happening.Your Knowledge PortfolioWe like to think of all the facts programmers know about computing, the application domains they work in, and all their experience as their Knowledge Portfolios. Managing a knowledge portfolio is very similar to managing a financial portfolio:Serious investors invest regularlyas a habit.1.Diversification is the key to long-term success.2.Smart investors balance their portfolios between conservative and high-risk, high-reward investments.3.Investors try to buy low and sell high for maximum return.4. Portfolios should be reviewed and rebalanced periodically.5.To be successful in your career, you must manage your knowledge portfolio using these same guidelines.Building Your PortfolioInvest regularly.   Just as in financial investing, you must invest in yourknowledge portfolio regularly. Even if it's just a small amount, the habit itself is as important as the sums. A few sample goals are listed in the next section. Diversify.   The more different things you know, the more valuable you are. As abaseline, you need to know the ins and outs of the particular technology you areworking with currently. But don't stop there. The face of computing changesrapidlyhot technology today may well be close to useless (or at least not indemand) tomorrow. The more technologies you are comfortable with, the better youwill be able to adjust to change. Manage risk.   Technology exists along a spectrum from risky, potentiallyhigh-reward to low-risk, low-reward standards. It's not a good idea to invest all of your money in high-risk stocks that might collapse suddenly, nor should you invest all of it conservatively and miss out on possible opportunities. Don't put all your technical eggs in one basket. Buy low, sell high.   Learning an emerging technology before it becomes popularcan be just as hard as finding an undervalued stock, but the payoff can be just as rewarding. Learning Java when it first came out may have been risky, but it paid off handsomely for the early adopters who are now at the top of that field. Review and rebalance.   This is a very dynamic industry. That hot technologyyou started investigating last month might be stone cold by now. Maybe you needto brush up on that database technology that you haven't used in a while. Orperhaps you could be better positioned for that new job opening if you tried out thatother language. Of all these guidelines, the most important one is the simplest to do:Tip 8  recommendations). Choose some that cover technology different from that of your current project.Get wired.   Want to know the ins and outs of a new language or othertechnology? Newsgroups are a great way to find out what experiences other people are having with it, the particular jargon they use, and so on. Surf the Web for papers, commercial sites, and any other sources of information you can find. It's important to continue investing. Once you feel comfortable with some new language or bit of technology, move on. Learn another one.It doesn't matter whether you ever use any of these technologies on a project, or even whether you put them on your resume. The process of learning will expand your thinking, opening you to new possibilities and new ways of doing things. The cross-pollination of ideas is important; try to apply the lessons you've learned to your current project. Even if your project doesn't use that technology, perhaps you can borrow some ideas. Get familiar with object orientation, for instance, and you'll write plain C programs differently.Opportunities for LearningSo you're reading voraciously, you're on top of all the latest breaking developments in your field (not an easy thing to do), and somebody asks you a question. You don't have the faintest idea what the answer is, and freely admit as much.Don't let it stop there. Take it as a personal challenge to find the answer. Ask a guru. (If you don't have a guru in your office, you should be able to find one on the Internet: see the box on on the facing page.) Search the Web. Go to the library.[4] [4] In this era of the Web, many people seem to have forgotten about real live libraries filled with researchmaterial and staff.If you can't find the answer yourself, find out who can. Don't let it rest. Talking to otherpeople will help build your personal network, and you may surprise yourself by findingsolutions to other, unrelated problems along the way. And that old portfolio just keepsgetting bigger.All of this reading and researching takes time, and time is already in short supply. So youneed to plan ahead. Always have something to read in an otherwise dead moment. Timespent waiting for doctors and dentists can be a great opportunity to catch up on yourreadingbut be sure to bring your own magazine with you, or you might find yourself thumbing through a dog-eared 1973 article about Papua New Guinea.Critical ThinkingThe last important point is to think critically about what you read and hear. You need to ensure that the knowledge in your portfolio is accurate and unswayed by either vendor or media hype. Beware of the zealots who insist that their dogma provides the onlyanswerit may or may not be applicable to you and your project.Never underestimate the power of commercialism. Just because a Web search engine lists a hit first doesn't mean that it's the best match; the content provider can pay to get top billing. Just because a bookstore features a book prominently doesn't mean it's a good book, or even popular; they may have been paid to place it there.Tip 9Critically Analyze What You Read and HearUnfortunately, there are very few simple answers anymore. But with your extensive portfolio, and by applying some critical analysis to theCare and Cultivation of GurusWith the global adoption of the Internet, gurus suddenly are as close as your Enter key. So, how do you find one, and how do you get one to talk with you?We find there are some simple tricks.Know exactly what you want to ask, and be as specific as you can be. Frame your question carefully and politely. Remember that you're asking a favor; don't seem to be demanding an answer. Once you've framed your questioned, stop and look again for the answer.    I l@ve RuBoard   Communicate!I believe that it is better to be looked over than it is to be overlooked.Mae West, Belle of the Nineties, 1934Maybe we can learn a lesson from Ms. West. It's not just what you've got, but also how you package it. Having the best ideas, the finest code, or the most pragmatic thinking is ultimately sterile unless you can communicate with other people. A good idea is an orphan without effective communication.As developers, we have to communicate on many levels. We spend hours in meetings, listening and talking. We work with end users, trying to understand their needs. We write code, which communicates our intentions to a machine and documents our thinking for future generations of developers. We write proposals and memos requesting and justifying resources, reporting our status, and suggesting new approaches. And we work daily within our teams to advocate our ideas, modify existing practices, and suggest new ones. A large part of our day is spent communicating, so we need to do it well.We've put together a list of ideas that we find useful.Know What You Want to SayProbably the most difficult part of the more formal styles of communication used in business is working out exactly what it is you want to say. Fiction writers plot out their books in detail before they start, but people writing technical documents are often happy to sit down at a keyboard, enter "1. Introduction," and start typing whatever comes into their heads next.Plan what you want to say. Write an outline. Then ask yourself, "Does this get across whatever I'm trying to say?" Refine it until it does.This approach is not just applicable to writing documents. When you're faced with an important meeting or a phone call with a major client, jot down the ideas you want to communicate, and plan a couple of strategies for getting them across.Know Your Audience   Be a ListenerThere's one technique that you must use if you want people to listen to you: listen to them.Even if this is a situation where you have all the information, even if this is a formalmeeting with you standing in front of 20 suitsif you don't listen to them, they won't listento you.Encourage people to talk by asking questions, or have them summarize what you tell them. Turn the meeting into a dialog, and you'll make your point more effectively. Who knows, you might even learn something.Get Back to PeopleIf you ask someone a question, you feel they're impolite if they don't respond. But how often do you fail to get back to people when they send you an e-mail or a memo asking for information or requesting some action? In the rush of everyday life, it's easy to forget. Always respond to e-mails and voice mails, even if the response is simply "I'll get back to you later." Keeping people informed makes them far more forgiving of the occasional slip, and makes them feel that you haven't forgotten them.Tip 10It's Both What You Say and the Way You Say ItUnless you work in a vacuum, you need to be able to communicate. The more effective that communication, the more influential you become.E-Mail CommunicationEverything we've said about communicating in writing applies equally to electronic mail. E-mail has evolved to the point where it is main-stay of intra- and intercorporate communications. E-mail is used to discuss contracts, to settle disputes, and as evidence in court. But for some reason, people who would  never send out a shabby paper document are happy to fling nasty-looking e-mail around the world.Our e-mail tips are simple:Proofread before you hit  . Check the spelling. Keep the format simple. Some people read e-mail using proportional fonts, so the ASCII art pictures you laboriously created will look to them like hen-scratchings. Use rich-text or HTML formatted mail only if you know that all your recipients can read it. Plain text is universal. Try to keep quoting to a minimum. No one likes to recieve back their own 100-line e-mail with "I agree" tacked on. If you're quoting other people's e-mail, be sure to attribute it, and quote it inline (rather than as an attachment). Don't flame unless you want it to come back and haunt you later. Check your list of recipients before sending. A recent Wall Street Journal article described an employee who took to distributing criticisms of his boss over departmental e-mail. without realizing that his boss was included on the distribution list. Archive and organize your e-mailboth the import stuff you receive andthe mail you send. As various microsoft and Netscape employees discovered during the 1999 Department of Justice investigation, e-mail is forever. Try to give the same attention and care to e-mail as you would to any written memo or report.I l@ve RuBoard    I l@ve RuBoard   SummaryKnow what you want to say. Know your audience. Choose your moment. Choose a style. Make it look good. Involve your audience. Be a listener. Get back to people. Related sections include:Prototypes and Post-it Notes Pragmatic Teams ChallengesThere are several good books that contain sections on communications within development teams [Bro95 , McC95 , DL99 ]. Make it a point to try to read all three over the next 18 months. In addition, the book Dinosaur Brains [Ber96 ] discusses the emotional baggage we all bring to the work environment. The next time you have to give a presentation, or write a memo advocating some position, try working through the wisdom acrostic before you start. See if it helpsyou understand how to position what you say. If appropriate, talk to your audience afterward and see how accurate your assessment of their needs was. I l@ve RuBoard    I l@ve RuBoard   Chapter 2. A Pragmatic ApproachThere are certain tips and tricks that apply at all levels of software development, ideas that are almost axiomatic, and processes that are virtually universal. However, these approaches are rarely documented as such; you'll mostly find them written down as odd sentences in discussions of design, project management, or coding.In this chapter we'll bring these ideas and processes together. The first two sections, The Evils of Duplication and Orthogonality, are closely related. The first warns you not to duplicate knowledge throughout your systems, the second not to split any one piece of knowledge across multiple system components.As the pace of change increases, it becomes harder and harder to keep our applications relevant. In Reversibility, we'll look at some techniques that help insulate your projects from their changing environment.The next two sections are also related. In Tracer Bullets, we talk about a style of development that allows you to gather requirements, test designs, and implement code at the same time. If this sounds too good to be true, it is: tracer bullet developments are not always applicable. When they're not, Prototypes and Post-it Notes shows you how to use prototyping to test architectures, algorithms, interfaces, and ideas.As computer science slowly matures, designers are producing increasingly higher-level languages. While the compiler that accepts "make it so" hasn't yet been invented, in Domain Languages we present some more modest suggestions that you can implement for yourself.Finally, we all work in a world of limited time and resources. You can survive both of these scarcities better (and keep your bosses happier) if you get good at working out how long things will take, which we cover in Estimating.By keeping these fundamental principles in mind during development, you can write code that's better, faster, and stronger. You can even make it look easy.I l@ve RuBoard     DRYDon't Repeat YourselfThe alternative is to have the same thing expressed in two or more places. If you change one, you have to remember to change the others, or, like the alien computers, your program will be brought to its knees by a contradiction. It isn't a question of whether you'll remember: it's a question of when you'll forget.You'll find the DRY principle popping up time and time again throughout this book, often in contexts that have nothing to do with coding. We feel that it is one of the most important tools in the Pragmatic Programmer's tool box.In this section we'll outline the problems of duplication and suggest general strategies for dealing with it.How Does Duplication Arise?Most of the duplication we see falls into one of the following categories:Imposed duplication.   Developers feel they have no choicethe environmentseems to require duplication. Inadvertent duplication.   Developers don't realize that they are duplicatinginformation. Impatient duplication.   Developers get lazy and duplicate because it seemseasier. Interdeveloper duplication.   Multiple people on a team (or on different teams)duplicate a piece of information. Let's look at these four i's of duplication in more detail.Imposed DuplicationSometimes, duplication seems to be forced on us. Project standards may require  documents that contain duplicated information, or documents that duplicate information in the code. Multiple target platforms each require their own programming languages, libraries, and development environments, which makes us duplicate shared definitions and procedures. Programming languages themselves require certain structures that duplicate information. We have all worked in situations where we felt powerless to avoid duplication. And yet often there are ways of keeping each piece of knowledge in one place, honoring the DRY principle, and making our lives easier at the same time. Here are some techniques:Multiple representations of information.   At the coding level, we often need to havethe same information represented in different forms. Maybe we're writing a client-server application, using different languages on the client and server, and need to represent some shared structure on both. Perhaps we need a class whose attributes mirror the schema of a database table. Maybe you're writing a book and want to include excerpts of programs that you also will compile and test.With a bit of ingenuity you can normally remove the need for duplication. Often the answer is to write a simple filter or code generator. Structures in multiple languages can be built from a common metadata representation using a simple code generator each time the software is built (an example of this is shown in Figure 3.4 ). Class definitions can be generated automatically from the online database schema, or from the metadata used to build the schema in the first place. The code extracts in this book are inserted by a preprocessor each time we format the text. The trick is to make the process active: this cannot be a one-time conversion, or we're back in a position of duplicating data.Documentation in code.  Programmers are taught to comment their code: good codehas lots of comments. Unfortunately, they are never taught why code needs comments: bad code requires lots of comments.The DRY principle tells us to keep the low-level knowledge in the code, where it belongs, and reserve the comments for other, high-level explanations. Otherwise, we're duplicating knowledge, and every change means changing both the code and the comments. The comments will inevitably become out of date, and untrustworthy comments are worse than no comments at all. (See It's All Writing , for more information on comments.)Documentation and code.   You write documentation, then you write code. Somethingchanges, and you amend the documentation and update the code. The documentation and code both contain representations of the same knowledge. And we all know that in the heat of the moment, with deadlines looming and important clients clamoring, we tend to defer  the updating of documentation.Dave once worked on an international telex switch. Quite understandably, the client demanded an exhaustive test specification and required that the software pass all tests on each delivery. To ensure that the tests accurately reflected the specification, the team generated them programmatically from the document itself. When the client amended their specification, the test suite changed automatically. Once the team convinced the client that the procedure was sound, generating acceptance tests typically took only a few seconds.Language issues.   Many languages impose considerable duplication in the source.Often this comes about when the language separates a module's interface from its implementation. C and C++ have header files that duplicate the names and type information of exported variables, functions, and (for C++) classes. Object Pascal even duplicates this information in the same file. If you are using remote procedure calls or CORBA [URL 29 ], you'll duplicate interface information between the interface specification and the code that implements it.There is no easy technique for overcoming the requirements of a language. While some development environments hide the need for header files by generating them automatically, and Object Pascal allows you to abbreviate repeated function declarations, you are generally stuck with what you're given. At least with most language-based issues, a header file that disagrees with the implementation will generate some form of compilation or linkage error. You can still get things wrong, but at least you'll be told about it fairly early on.Think also about comments in header and implementation files. There is absolutely no point in duplicating a function or class header comment between the two files. Use the header files to document interface issues, and the implementation files to document the nitty-gritty details that users of your code don't need to know.Inadvertent DuplicationSometimes, duplication comes about as the result of mistakes in the design.Let's look at an example from the distribution industry. Say our analysis reveals that, among other attributes, a truck has a type, a license number, and a driver. Similarly, a delivery route is a combination of a route, a truck, and a driver. We code up some classes based on this understanding. But what happens when Sally calls in sick and we have to change drivers? Both Truck and DeliveryRoute contain a driver. Which one do we change? Clearly this duplication is bad.Normalize it according to the underlying business modeldoes a truck really have a driveras part of its underlying attribute set? Does a route? Or maybe there needs to be a thirdobject that knits together a driver, a truck, and a route. Whatever the eventual solution,avoid this kind of unnormalized data.There is a slightly less obvious kind of unnormalized data that occurs when we have multiple data elements that are mutually dependent. Let's look at a class representing a line:                                            class Line {     public:      Point  start;      Point  end;      double length;    };At first sight, this class might appear reasonable. A line clearly has a start and end, and will always have a length (even if it's zero). But we have duplication. The length is defined by the start and end points: change one of the points and the length changes. It's better to make the length a calculated field:                                            class Line {     public:      Point  start;      Point  end;      double length() { return start.distanceTo(end); }    };Later on in the development process, you may choose to violate the DRY principle for performance reasons. Frequently this occurs when you need to cache data to avoid repeating expensive operations. The trick is to localize the impact. The violation is not exposed to the outside world: only the methods within the class have to worry about keeping things straight.                                            class Line {  If you feel this temptation, remember the hackneyed aphorism "shortcuts make for long delays." You may well save some seconds now, but at the potential loss of hours later. Think about the issues surrounding the Y2K fiasco. Many were caused by the laziness of developers not parameterizing the size of date fields or implementing centralized libraries of date services.Impatient duplication is an easy form to detect and handle, but it takes discipline and a willingness to spend time up front to save pain later.Interdeveloper DuplicationOn the other hand, perhaps the hardest type of duplication to detect and handle occurs between different developers on a project. Entire sets of functionality may be inadvertently duplicated, and that duplication could go undetected for years, leading to maintenance problems. We heard firsthand of a U.S. state whose governmental computer systems were surveyed for Y2K compliance. The audit turned up more than 10,000 programs, each containing its own version of Social Security number validation.At a high level, deal with the problem by having a clear design, a strong technical project leader (see Pragmatic Teams ), and a well-understood division of responsibilities within the design. However, at the module level, the problem is more insidious. Commonly needed functionality or data that doesn't fall into an obvious area of responsibility can get implemented many times over.We feel that the best way to deal with this is to encourage active and frequentcommunication between developers. Set up forums to discuss common problems. (Onpast projects, we have set up private Usenet newsgroups to allow developers to exchangeideas and ask questions. This provides a nonintrusive way of communicatingeven acrossmultiple siteswhile retaining a permanent history of everything said.) Appoint a teammember as the project librarian, whose job is to facilitate the exchange of knowledge. Havea central place in the source tree where utility routines and scripts can be deposited. Andmake a point of reading other people's source code and documentation, either informally orduring code reviews. You're not snoopingyou're learning from them. And remember, theaccess is reciprocaldon't get twisted about other people poring (pawing?) through yourcode, either.Tip 12Make It Easy to Reuse What you're trying to do is foster an environment where it's easier to find and reuse existing stuff than to write it yourself. If it isn't easy, people won't do it. And if you fail to reuse, you risk duplicating knowledge.Related sections include:Orthogonality Text Manipulation Code Generators Refactoring Pragmatic Teams Ubiquitous Automation It's All Writing I l@ve RuBoard    I l@ve RuBoard   OrthogonalityOrthogonality is a critical concept if you want to produce systems that are easy to design, build, test, and extend. However, the concept of orthogonality is rarely taught directly. Often it is an implicit feature of various other methods and techniques you learn. This is a mistake. Once you learn to apply the principle of orthogonality directly, you'll notice an immediate improvement in the quality of systems you produce.What Is Orthogonality?"Orthogonality" is a term borrowed from geometry. Two lines are orthogonal if they meet at right angles, such as the axes on a graph. In vector terms, the two lines are independent.Move along one of the lines, and your position projected onto the other doesn't change. In computing, the term has come to signify a kind of independence or decoupling. Two or more things are orthogonal if changes in one do not affect any of the others. In a well-designed system, the database code will be orthogonal to the user interface: you can change the interface without affecting the database, and swap databases without changing the interface.Before we look at the benefits of orthogonal systems, let's first look at a system that isn't orthogonal.A Nonorthogonal SystemYou're on a helicopter tour of the Grand Canyon when the pilot, who made the obvious  mistake of eating fish for lunch, suddenly groans and faints. Fortunately, he left you hovering 100 feet above the ground. You rationalize that the collective pitch lever[2]  controlsoverall lift, so lowering it slightly will start a gentle descent to the ground. However, when you try it, you discover that life isn't that simple. The helicopter's nose drops, and you start to spiral down to the left. Suddenly you discover that you're flying a system where every control input has secondary effects. Lower the left-hand lever and you need to add compensating backward movement to the right-hand stick and push the right pedal. But then each of these changes affects all of the other controls again. Suddenly you're juggling an unbelievably complex system, where every change impacts all the other inputs. Your workload is phenomenal: your hands and feet are constantly moving, trying to balance all the interacting forces. [2] Helicopters have four basic controls. The cyclic is the stick you hold in your right hand. Move it, and the helicopter moves in the corresponding direction. Your left hand holds the collective pitch lever. Pull up on this and you increase the pitch on all the blades, generating lift. At the end of the pitch lever is the throttle. Finally you have two foot pedals, which vary the amount of tail rotor thrust and so help turn the helicopter.Helicopter controls are decidedly not orthogonal.Benefits of OrthogonalityAs the helicopter example illustrates, nonorthogonal systems are inherently more complex to change and control. When components of any system are highly interdependent, there is no such thing as a local fix.Tip 13Eliminate Effects Between Unrelated ThingsWe want to design components that are self-contained: independent, and with a single, well-defined purpose (what Yourdon and Constantine call cohesion [YC86 ]). When components are isolated from one another, you know that you can change one without having to worry about the rest. As long as you don't change that component's external interfaces, you can be comfortable that you won't cause problems that ripple through the entire system. You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.Gain ProductivityChanges are localized, so development time and testing time are reduced. It iseasier to write relatively small, self-contained components than a single large blockof code. Simple components can be designed, coded, unit tested, and thenforgottenthere is no need to keep changing existing code as you add new code. An orthogonal approach also promotes reuse. If components have specific, well-defined responsibilities, they can be combined with new components in ways that were not envisioned by their original implementors. The more loosely coupled your systems, the easier they are to reconfigure and reengineer. There is a fairly subtle gain in productivity when you combine orthogonal components. Assume that one component does M distinct things and another does N things. If they are orthogonal and you combine them, the result does M × Nthings. However, if the two components are not orthogonal, there will be overlap, and the result will do less. You get more functionality per unit effort by combining orthogonal components. Reduce RiskAn orthogonal approach reduces the risks inherent in any development.Diseased sections of code are isolated. If a module is sick, it is less likely to spread the symptoms around the rest of the system. It is also easier to slice it out and transplant in something new and healthy. The resulting system is less fragile. Make small changes and fixes to a particular area, and any problems you generate will be restricted to that area. An orthogonal system will probably be better tested, because it will be easier to design and run tests on its components. You will not be as tightly tied to a particular vendor, product, or platform, because the interfaces to these third-party components will be isolated to smaller parts of the overall development.  Let's look at some of the ways you can apply the principle of orthogonality to your work.Project TeamsHave you noticed how some project teams are efficient, with everyone knowing what to do and contributing fully, while the members of other teams are constantly bickering and don't seem able to get out of each other's way?Often this is an orthogonality issue. When teams are organized with lots of overlap, members are confused about responsibilities. Every change needs a meeting of the entire team, because any one of them might be affected.How do you organize teams into groups with well-defined responsibilities and minimal overlap? There's no simple answer. It depends partly on the project and your analysis of the areas of potential change. It also depends on the people you have available. Our preference is to start by separating infrastructure from application. Each major infrastructure component (database, communications interface, middleware layer, and so on) gets its own subteam. Each obvious division of application functionality is similarly divided. Then we look at the people we have (or plan to have) and adjust the groupings accordingly.You can get an informal measure of the orthogonality of a project team's structure. Simply see how many people need to be involved in discussing each change that is requested. The larger the number, the less orthogonal the group. Clearly, an orthogonal team is more efficient. (Having said this, we also encourage subteams to communicate constantly with each other.)DesignMost developers are familiar with the need to design orthogonal systems, although they may use words such as modular, component-based, and layered to describe the process. Systems should be composed of a set of cooperating modules, each of which implements functionality independent of the others. Sometimes these components are organized into layers, each providing a level of abstraction. This layered approach is a powerful way to design orthogonal systems. Because each layer uses only the abstractions provided by the layers below it, you have great flexibility in changing underlying implementations without affecting code. Layering also reduces the risk of runaway dependencies between modules. You'll often see layering expressed in diagrams such as   Toolkits and LibrariesBe careful to preserve the orthogonality of your system as you introduce third-party toolkits and libraries. Choose your technologies wisely.We once worked on a project that required that a certain body of Java code run both locallyon a server machine and remotely on a client machine. The alternatives for distributingclasses this way were RMI and CORBA. If a class were made remotely accessible usingRMI, every call to a remote method in that class could potentially throw an exception,which means that a naive implementation would require us to handle the exceptionwhenever our remote classes were used. Using RMI here is clearly not orthogonal: codecalling our remote classes should not have to be aware of their locations. Thealternativeusing CORBAdid not impose that restriction: we could write code that wasunaware of our classes' locations.When you bring in a toolkit (or even a library from other members of your team), ask yourself whether it imposes changes on your code that shouldn't be there. If an object persistence scheme is transparent, then it's orthogonal. If it requires you to create or access objects in a special way, then it's not. Keeping such details isolated from your code has the added benefit of making it easier to change vendors in the future.The Enterprise Java Beans (EJB) system is an interesting example of orthogonality. In most transaction-oriented systems, the application code has to delineate the start and end of each transaction. With EJB, this information is expressed declaratively as metadata, outside any code. The same application code can run in different EJB transaction environments with no change. This is likely to be a model for many future environments.Another interesting twist on orthogonality is Aspect-Oriented Programming (AOP), a research project at Xerox Parc ([KLM + 97 ] and [URL 49 ]). AOP lets you express in one place behavior that would otherwise be distributed throughout your source code. For example, log messages are normally generated by sprinkling explicit calls to some log function throughout your source. With AOP, you implement logging orthogonally to the things being logged. Using the Java version of AOP, you could write a log message when entering any method of class Fred by coding the aspect:                                            aspect Trace {      advise * Fred.*(..) {        static before {  Avoid similar functions.   Often you'll come across a set of functions that all looksimilarmaybe they share common code at the start and end, but each has adifferent central algorithm. Duplicate code is a symptom of structural problems.Have a look at the Strategy pattern in Design Patterns for a better implementation. Get into the habit of being constantly critical of your code. Look for any opportunities to reorganize it to improve its structure and orthogonality. This process is called refactoring,and it's so important that we've dedicated a section to it (see Refactoring ).TestingAn orthogonally designed and implemented system is easier to test. Because the interactions between the system's components are formalized and limited, more of the system testing can be performed at the individual module level. This is good news, because module level (or unit) testing is considerably easier to specify and perform than integration testing. In fact, we suggest that every module have its own unit test built into its code, and that these tests be performed automatically as part of the regular build process (see Code That's Easy to Test ).Building unit tests is itself an interesting test of orthogonality. What does it take to build and link a unit test? Do you have to drag in a large percentage of the rest of the system just to get a test to compile or link? If so, you've found a module that is not well decoupled from the rest of the system.Bug fixing is also a good time to assess the orthogonality of the system as a whole. When you come across a problem, assess how localized the fix is. Do you change just one module, or are the changes scattered throughout the entire system? When you make a change, does it fix everything, or do other problems mysteriously arise? This is a good opportunity to bring automation to bear. If you use a source code control system (and you will after reading Source Code Control ), tag bug fixes when you check the code back in after testing. You can then run monthly reports analyzing trends in the number of source files affected by each bug fix.DocumentationPerhaps surprisingly, orthogonality also applies to documentation. The axes are content and presentation. With truly orthogonal documentation, you should be able to change the appearance dramatically without changing the content. Modern word processors provide  style sheets and macros that help (see It's All Writing ).Living with OrthogonalityOrthogonality is closely related to the DRY principle introduced on page 27. With DRY,you're looking to minimize duplication within a system, whereas with orthogonality you reduce the interdependency among the system's components. It may be a clumsy word, but if you use the principle of orthogonality, combined closely with the DRY principle, you'll find that the systems you develop are more flexible, more understandable, and easier to debug, test, and maintain.If you're brought into a project where people are desperately struggling to make changes, and where every change seems to cause four other things to go wrong, remember the nightmare with the helicopter. The project probably is not orthogonally designed and coded. It's time to refactor.And, if you're a helicopter pilot, don't eat the fish.Related sections include:The Evils of Duplication Source Code Control Design by Contract Decoupling and the Law of Demeter Metaprogramming It's Just a View Refactoring Code That's Easy to Test Evil Wizards Pragmatic Teams It's All Writing  ChallengesConsider the difference between large GUI-oriented tools typically found on Windows systems and small but combinable command line utilities used at shell prompts. Which set is more orthogonal, and why? Which is easier to use for exactly the purpose for which it was intended? Which set is easier to combine with other tools to meet new challenges? C++ supports multiple inheritance, and Java allows a class to implement multiple interfaces. What impact does using these facilities have on orthogonality? Is there a difference in impact between using multiple inheritance and multiple interfaces? Is there a difference between using delegation and using inheritance? Exercises 1.You are writing a class called Split, which splits input lines into fields. Which of  the following two Java class signatures is the more orthogonal design?                                                                     class Split1 {      public Split1(InputStreamReader rdr) { ...      public void readNextLine() throws IOException { ...      public int numFields() { ...      public String getField(int fieldNo) { ...    }    class Split2 {      public Split2(String line) { ...      public int numFields()     { ...      public String getField(int fieldNo) { ...    } 2.Which will lead to a more orthogonal design: modeless or modal dialog boxes? 3.How about procedural languages versus object technology? Which results in a   more orthogonal system? I l@ve RuBoard      Tip 14There Are No Final DecisionsFlexible ArchitectureWhile many people try to keep their code flexible, you also need to think about maintaining flexibility in the areas of architecture, deployment, and vendor integration.Technologies such as CORBA can help insulate portions of a project from changes in development language or platform. Is the performance of Java on that platform not up to expectations? Recode the client in C++, and nothing else needs to change. Is the rules engine in C++ not flexible enough? Switch over to a Smalltalk version. With a CORBA architecture, you have to take a hit only for the component you are replacing; the other components shouldn't be affected.Are you developing for Unix? Which one? Do you have all of the portability concernsaddressed? Are you developing for a particular version of Windows? Which one3.1, 95,98, NT, CE, or 2000? How hard will it be to support other versions? If you keep decisionssoft and pliable, it won't be hard at all. If you have poor encapsulation, high coupling, andhard-coded logic or parameters in the code, it might be impossible.Not sure how marketing wants to deploy the system? Think about it up front and you can support a stand-alone, client-server, or n-tier model just by changing a configuration file. We've written programs that do just that.Normally, you can simply hide a third-party product behind a well-defined, abstract interface. In fact, we've always been able to do so on any project we've worked on. But suppose you couldn't isolate it that cleanly. What if you had to sprinkle certain statements liberally throughout the code? Put that requirement in metadata, and use some automatic mechanism, such as Aspects (see page 39) or Perl, to insert the necessary statements into the code itself. Whatever mechanism you use, make it reversible. If something is added automatically, it can be taken out automatically as well.No one knows what the future may hold, especially not us! So enable your code to  rock-n-roll: to "rock on" when it can, to roll with the punches when it must.Related sections include:Decoupling and the Law of Demeter Metaprogramming It's Just a View ChallengesTime for a little quantum mechanics with Schrödinger's cat. Suppose you have acat in a closed box, along with a radioactive particle. The particle has exactly a 50% chance of fissioning into two. If it does, the cat will be killed. If it doesn't, the cat will be okay. So, is the cat dead or alive? According to Schrödinger, the correct answeris both. Every time a sub-nuclear reaction takes place that has two possible outcomes, the universe is cloned. In one, the event occurred, in the other it didn't. The cat's alive in one universe, dead in another. Only when you open the box do you know which universe you are in.No wonder coding for the future is difficult.But think of code evolution along the same lines as a box full of Schrödinger's cats:every decision results in a different version of the future. How many possible futures can your code support? Which ones are more likely? How hard will it be to support them when the time comes?Dare you open the box? I l@ve RuBoard    I l@ve RuBoard   Tracer BulletsReady, fire, aimThere are two ways to fire a machine gun in the dark.[5]  You can find out exactly whereyour target is (range, elevation, and azimuth). You can determine the environmental conditions (temperature, humidity, air pressure, wind, and so on). You can determine the precise specifications of the cartridges and bullets you are using, and their interactions with the actual gun you are firing. You can then use tables or a firing computer to calculate the exact bearing and elevation of the barrel. If everything works exactly as specified, your tables are correct, and the environment doesn't change, your bullets should land close to their target. [5] To be pedantic, there are many ways of firing a machine gun in the dark, including closing your eyesand spraying out bullets. But this is an analogy, and we're allowed to take liberties.Or you could use tracer bullets.Tracer bullets are loaded at intervals on the ammo belt alongside regular ammunition. When they're fired, their phosphorus ignites and leaves a pyrotechnic trail from the gun to whatever they hit. If the tracers are hitting the target, then so are the regular bullets.Not surprisingly, tracer bullets are preferred to the labor of calculation. The feedback is immediate, and because they operate in the same environment as the real ammunition, external effects are minimized.The analogy might be violent, but it applies to new projects, particularly when you're building something that hasn't been built before. Like the gunners, you're trying to hit a target in the dark. Because your users have never seen a system like this before, their requirements may be vague. Because you may be using algorithms, techniques, languages, or libraries you aren't familiar with, you face a large number of unknowns. And because projects take time to complete, you can pretty much guarantee the environment you're working in will change before you're done.The classic response is to specify the system to death. Produce reams of paper itemizing every requirement, tying down every unknown, and constraining the environment. Fire the gun using dead reckoning. One big calculation up front, then shoot and hope. Pragmatic Programmers, however, tend to prefer using tracer bullets.Code That Glows in the DarkTracer bullets work because they operate in the same environment and under the same constraints as the real bullets. They get to the target fast, so the gunner gets immediate feedback. And from a practical standpoint they're a relatively cheap solution.To get the same effect in code, we're looking for something that gets us from a requirement to some aspect of the final system quickly, visibly, and repeatably.Tip 15Use Tracer Bullets to Find the TargetWe once undertook a complex client-server database marketing project. Part of its requirement was the ability to specify and execute temporal queries. The servers were a range of relational and specialized databases. The client GUI, written in Object Pascal, used a set of C libraries to provide an interface to the servers. The user's query was stored on the server in a Lisp-like notation before being converted to optimized SQL just prior to execution. There were many unknowns and many different environments, and no one was too sure how the GUI should behave.This was a great opportunity to use tracer code. We developed the framework for the front end, libraries for representing the queries, and a structure for converting a stored query into a database-specific query. Then we put it all together and checked that it worked. For that initial build, all we could do was submit a query that listed all the rows in a table, but it proved that the UI could talk to the libraries, the libraries could serialize and unserialize a query, and the server could generate SQL from the result. Over the following months we gradually fleshed out this basic structure, adding new functionality by augmenting each component of the tracer code in parallel. When the UI added a new query type, the library grew and the SQL generation was made more sophisticated.Tracer code is not disposable: you write it for keeps. It contains all the error checking, structuring, documentation, and self-checking that any piece of production code has. It simply is not fully functional. However, once you have achieved an end-to-end connection  among the components of your system, you can check how close to the target you are, adjusting if necessary. Once you're on target, adding functionality is easy.Tracer development is consistent with the idea that a project is never finished: there will always be changes required and functions to add. It is an incremental approach.The conventional alternative is a kind of heavy engineering approach: code is divided into modules, which are coded in a vacuum. Modules are combined into subassemblies, which are then further combined, until one day you have a complete application. Only then can the application as a whole be presented to the user and tested.The tracer code approach has many advantages:Users get to see something working early.   If you have successfullycommunicated what you are doing (see Great Expectations ), your users will know they are seeing something immature. They won't be disappointed by a lack of functionality; they'll be ecstatic to see some visible progress toward their system. They also get to contribute as the project progresses, increasing their buy-in. These same users will likely be the people who'll tell you how close to the target each iteration is. Developers build a structure to work in.   The most daunting piece of paper isthe one with nothing written on it. If you have worked out all the end-to-end interactions of your application, and have embodied them in code, then your team won't need to pull as much out of thin air. This makes everyone more productive, and encourages consistency. You have an integration platform.   As the system is connected end-to-end, youhave an environment to which you can add new pieces of code once they have been unit-tested. Rather than attempting a big-bang integration, you'll be integrating every day (often many times a day). The impact of each new change is more apparent, and the interactions are more limited, so debugging and testing are faster and more accurate. You have something to demonstrate.   Project sponsors and top brass have atendency to want to see demos at the most inconvenient times. With tracer code, you'll always have something to show them. You have a better feel for progress.   In a tracer code development,developers tackle use cases one by one. When one is done, they move to the next.    algorithms in their final environment, interfacing to the real world. This is prototyping, and it is very useful.The tracer code approach addresses a different problem. You need to know how the application as a whole hangs together. You want to show your users how the interactions will work in practice, and you want to give your developers an architectural skeleton on which to hang code. In this case, you might construct a tracer consisting of a trivial implementation of the container packing algorithm (maybe something like first-come, first-served) and a simple but working user interface. Once you have all the components in the application plumbed together, you have a framework to show your users and your developers. Over time, you add to this framework with new functionality, completing stubbed routines. But the framework stays intact, and you know the system will continue to behave the way it did when your first tracer code was completed.The distinction is important enough to warrant repeating. Prototyping generates disposable code. Tracer code is lean but complete, and forms part of the skeleton of the final system. Think of prototyping as the reconnaissance and intelligence gathering that takes place before a single tracer bullet is fired.Related sections include:Good-Enough Software Prototypes and Post-it Notes The Specification Trap Great Expectations I l@ve RuBoard    I l@ve RuBoard   Prototypes and Post-it NotesMany different industries use prototypes to try out specific ideas; prototyping is muchcheaper than full-scale production. Car makers, for example, may build many differentprototypes of a new car design. Each one is designed to test a specific aspect of thecarthe aerodynamics, styling, structural characteristics, and so on. Perhaps a clay modelwill be built for wind tunnel testing, maybe a balsa wood and duct tape model will do for theart department, and so on. Some car companies take this a step further, and now do agreat deal of modeling work on the computer, reducing costs even further. In this way, riskyor uncertain elements can be tried out without committing to building the real item.We build software prototypes in the same fashion, and for the same reasonsto analyzeand expose risk, and to offer chances for correction at a greatly reduced cost. Like the carmakers, we can target a prototype to test one or more specific aspects of a project.We tend to think of prototypes as code-based, but they don't always have to be. Like the car makers, we can build prototypes out of different materials. Post-it notes are great for prototyping dynamic things such as workflow and application logic. A user interface can be prototyped as a drawing on a whiteboard, as a nonfunctional mock-up drawn with a paint program, or with an interface builder.Prototypes are designed to answer just a few questions, so they are much cheaper andfaster to develop than applications that go into production. The code can ignoreunimportant detailsunimportant to you at the moment, but probably very important to theuser later on. If you are prototyping a GUI, for instance, you can get away with incorrectresults or data. On the other hand, if you're just investigating computational or performanceaspects, you can get away with a pretty poor GUI, or perhaps even no GUI at all.But if you find yourself in an environment where you cannot give up the details, then you need to ask yourself if you are really building a prototype at all. Perhaps a tracer bullet style of development would be more appropriate in this case (see Tracer Bullets ).Things to PrototypeWhat sorts of things might you choose to investigate with a prototype? Anything that carries risk. Anything that hasn't been tried before, or that is absolutely critical to the final system. Anything unproven, experimental, or doubtful. Anything you aren't comfortable  with. You can prototypeArchitecture New functionality in an existing system Structure or contents of external data Third-party tools or components Performance issues User interface design Prototyping is a learning experience. Its value lies not in the code produced, but in the lessons learned. That's really the point of prototyping.Tip 16Prototype to LearnHow to Use PrototypesWhen building a prototype, what details can you ignore?Correctness.   You may be able to use dummy data where appropriate. Completeness.   The prototype may function only in a very limited sense, perhapswith only one preselected piece of input data and one menu item. Robustness.   Error checking is likely to be incomplete or missing entirely. If youstray from the predefined path, the prototype may crash and burn in a glorious display of pyrotechnics. That's okay. Style.   It is painful to admit this in print, but prototype code probably doesn't havemuch in the way of comments or documentation. You may produce reams of documentation as a result of your experience with the prototype, but comparatively   very little on the prototype system itself.Since a prototype should gloss over details, and focus in on specific aspects of the systembeing considered, you may want to implement prototypes using a very high-levellanguagehigher than the rest of the project (maybe a language such as Perl, Python, orTcl). A high-level scripting language lets you defer many details (including specifying datatypes) and still produce a functional (albeit incomplete or slow) piece of code.[6]  If you needto prototype user interfaces, investigate tools such as Tcl/Tk, Visual Basic, Powerbuilder, or Delphi. [6] If you are investigating absolute (instead of relative) performance, you will need to stick to a languagethat is close in performance to the target language.Scripting languages work well as the "glue" to combine low-level pieces into newcombinations. Under Windows, Visual Basic can glue together COM controls. Moregenerally, you can use languages such as Perl and Python to bind together low-level Clibrarieseither by hand, or automatically with tools such as the freely available SWIG[URL 28 ]. Using this approach, you can rapidly assemble existing components into new configurations to see how things work.Prototyping ArchitectureMany prototypes are constructed to model the entire system under consideration. Asopposed to tracer bullets, none of the individual modules in the prototype system need tobe particularly functional. In fact, you may not even need to code in order to prototypearchitectureyou can prototype on a whiteboard, with Post-it notes or index cards. Whatyou are looking for is how the system hangs together as a whole, again deferring details.Here are some specific areas you may want to look for in the architectural prototype:Are the responsibilities of the major components well defined and appropriate? Are the collaborations between major components well defined? Is coupling minimized? Can you identify potential sources of duplication? Are interface definitions and constraints acceptable? Does every module have an access path to the data it needs during execution?   Does it have that access when it needs it?This last item tends to generate the most surprises and the most valuable results from the prototyping experience.How Not to Use PrototypesBefore you embark on any code-based prototyping, make sure that everyone understands that you are writing disposable code. Prototypes can be deceptively attractive to people who don't know that they are just prototypes. You must make it very clear that this code is disposable, incomplete, and unable to be completed.It's easy to become misled by the apparent completeness of a demonstrated prototype, and project sponsors or management may insist on deploying the prototype (or its progeny) if you don't set the right expectations. Remind them that you can build a great prototype of a new car out of balsa wood and duct tape, but you wouldn't try to drive it in rush-hour traffic!If you feel there is a strong possibility in your environment or culture that the purpose of prototype code may be misinterpreted, you may be better off with the tracer bullet approach. You'll end up with a solid framework on which to base future development.When used properly, a prototype can save you huge amounts of time, money, pain, andsuffering by identifying and correcting potential problem spots early in the developmentcyclethe time when fixing mistakes is both cheap and easy.Related sections include:The Cat Ate My Source Code Communicate! Tracer Bullets Great Expectations Exercises  4.Marketing would like to sit down and brainstorm a few Web-page designs with you. They are thinking of clickable image maps to take you to other pages, and so on. But they can't decide on a model for the image?maybe it's a car, or a phone, or a house. You have a list of target pages and content; they'd like to see a few prototypes. Oh, by the way, you have 15 minutes. What tools might you use? I l@ve RuBoard    I l@ve RuBoard   Domain LanguagesThe limits of language are the limits of one's world.Ludwig Von WittgensteinComputer languages influence how you think about a problem, and how you think aboutcommunicating. Every language comes with a list of featuresbuzzwords such as staticversus dynamic typing, early versus late binding, inheritance models (single, multiple, ornone)all of which may suggest or obscure certain solutions. Designing a solution withLisp in mind will produce different results than a solution based on C-style thinking, andvice versa. Conversely, and we think more importantly, the language of the problemdomain may also suggest a programming solution.We always try to write code using the vocabulary of the application domain (see The  Requirements Pit , where we suggest using a project glossary). In some cases, we can goto the next level and actually program using the vocabulary, syntax, and semanticsthelanguageof the domain.When you listen to users of a proposed system, they might be able to tell you exactly how the system should work:Listen for transactions defined by ABC Regulation 12.3 on a set of X.25 lines, translate them to XYZ Company's format 43B, retransmit them on the satellite uplink, and store for future analysis.If your users have a number of such well-bounded statements, you can invent a mini-language tailored to the application domain that expresses exactly what they want:                                    From X25LINE1 (Format=ABC123) {      Put TELSTAR1 (Format=XYZ43B);      Store DB;    }This language need not be executable. Initially, it could be simply a way of capturing theuser's requirementsa specification. However, you may want to consider taking this a stepfurther and actually implementing the language. Your specification has become executable code.After you've written the application, the users give you a new requirement: transactions with negative balances shouldn't be stored, and should be sent back on the X.25 lines in the original format:                                    From X25LINE1 (Format=ABC123) {      if (ABC123.balance < 0) {        Put X25LINE1 (Format=ABC123);      }      else {        Put TELSTAR1 (Format=XYZ43B);        Store DB;      }    }That was easy, wasn't it? With the proper support in place, you can program much closer to the application domain. We're not suggesting that your end users actually program in these languages. Instead, you're giving yourself a tool that lets you work closer to their domain.Tip 17Program Close to the Problem domainWhether it's a simple language to configure and control an application program, or a more complex language to specify rules or procedures, we think you should consider ways of moving your project closer to the problem domain. By coding at a higher level of abstraction, you are free to concentrate on solving domain problems, and can ignore petty implementation details.Remember that there are many users of an application. There's the end user, who understands the business rules and the required outputs. There are also secondary users: operations staff, configuration and test managers, support and maintenance programmers, and future generations of developers. Each of these users has their own problem domain, and you can generate mini-environments and languages for all of them. Domain-Specific ErrorsIf you are writing in the problem domain, you can also perform domain-specific validation, reporting problems in terms your users can understand. Take our switching application on on the facing page. Suppose the user misspelled the format name:                                            From X25LINE1 (Format=AB123)If this happened in a standard , general-purpose programming language, you might receive a standard, general-purpose error message:                                            Syntax error: undeclared identifierBut with a mini-launguage, you would instead be able to issue an error message using the vocabulary of the domain:                                            "AB123" is not a format. known formats are ABC123,            XYZ43B, PDQB, and 42.Implementing a Mini-LanguageAt its simplest, a mini-language may be in a line-oriented, easily parsed format. In practice, we probably use this form more than any other. It can be parsed simply using switchstatements, or using regular expressions in scripting languages such as Perl. The answer to Exercise 5 on page 281 shows a simple implementation in C.You can also implement a more complex language, with a more formal syntax. The trick here is to define the syntax first using a notation such as BNF.[7]  Once you have yourgrammar specified, it is normally trivial to convert it into the input syntax for a parser generator. C and C++ programmers have been using yacc (or its freely available implementation, bison [URL 27 ]) for years. These programs are documented in detail in the book Lex and Yacc [LMB92 ]. Java programmers can try javaCC, which can be found at [URL 26 ]. The answer to Exercise 7 on page 282 shows a parser written using bison. As it shows, once you know the syntax, it's really not a lot of work to write simple  mini-languages. [7] BNF, or Backus-Naur Form, lets you specify context-free grammars recursively. Any good book on compiler construction or parsing will cover BNF in (exhaustive) detail.There's another way of implementing a mini-language: extend an existing one. For example, you could integrate application-level functionality with (say) Python [URL 9 ] and write something like[8] [8] Thanks to Eric Vought for this example.                                            record = X25LINE1.get(format=ABC123)    if (record.balance < 0):            X25LINE1.put(record, format=ABC123)    else:            TELSTAR1.put(record, format=XYZ43B)            DB.store(record)Data Languages and Imperative LanguagesThe languages you implement can be used in two different ways.Data languages produce some form of data structure used by an application. These languages are often used to represent configuration information.For example, the sendmail program is used throughout the world for routing e-mail over the Internet. It has many excellent features and benefits, which are controlled by a thousand-line configuration file, written using sendmail's own configuration language:                                                    Mlocal, P=/usr/bin/procmail,            F=lsDFMAw5 :/|@qSPfhn9,            S=10/30, R=20/40,            T=DNS/RFC822/X-Unix,            A=procmail -Y -a $h -d $uObviously, readability is not one of sendmail's strengths.For years, Microsoft has been using a data language that can describe menus, widgets, dialog boxes, and other Windows resources. Figure 2.2  on the next page shows an excerpt       waitfor keyboardunlock    if text_at(10,14) is "INVALID SSN" return bad_ssn    if text_at(10,14) is "DUPLICATE SSN" return dup_ssn    # etc...                                                When the application determines it is time to enter a Social Security number, it invokes the interpreter on this script, which then controls the transaction. If the interpreter is embedded within the application, the two can even share data directly (for example, via a callback mechanism).Here you're programming in the maintenance programmer's domain. When the mainframe application changes, and the fields move around, the programmer can simply update your high-level description, rather than groveling around in the details of C code.Stand-Alone and Embedded LanguagesA mini-language doesn't have to be used directly by the application to be useful. Many times we may use a specification language to create artifacts (including metadata) that are compiled, read-in, or otherwise used by the program itself (see Metaprogramming ).For example, on page 100 we describe a system in which we used Perl to generate a largenumber of derivations from an original schema specification. We invented a commonlanguage to express the database schema, and then generated all the forms of it weneededSQL, C, Web pages, XML, and others. The application didn't use thespecification directly, but it relied on the output produced from it.It is common to embed high-level imperative languages directly into your application, so that they execute when your code runs. This is clearly a powerful capability; you can change your application's behavior by changing the scripts it reads, all without compiling. This can significantly simplify maintenance in a dynamic application domain.Easy Development or Easy Maintenance?We've looked at several different grammars, ranging from simple line-oriented formats to more complex grammars that look like real languages. Since it takes extra effort to implement, why would you choose a more complex grammar? The trade-off is extendibility and maintenance. While the code for parsing a "real" languagemay be harder to write, it will be much easier for people to understand, and to extend in thefuture with new features and functionality. Languages that are too simple may be easy toparse, but can be crypticmuch like the sendmail example on page 60.Given that most applications exceed their expected lifetimes, you're probably better off biting the bullet and adopting the more complex and readable language up front. The initial effort will be repaid many times in reduced support and maintenance costs.Related sections include:Metaprogramming ChallengesCould some of the requirements of your current project be expressed in a domain-specific language? Would it be possible to write a compiler or translator that could generate most of the code required? If you decide to adopt mini-languages as a way of programming closer to the problem domain, you're accepting that some effort will be required to implement them. Can you see ways in which the framework you develop for one project can be reused in others? Exercises 5.We want to implement a mini-language to control a simple drawing package  (perhaps a turtle-graphics system). The language consists of single-letter  commands. Some commands are followed by a single number. For example,  the following input would draw a rectangle .                                                                    P 2 # select pen 2    D   # pen down    W 2 # draw west 2cm    N 1 # then north 1     E 2 # then east 2    S 1 # then back south    U   # pen up                                                                Implement the code that parses this language. It should be designed so that it is simple to add new commands. 6.Design a BNF grammar to parse a time specification. All of the following  examples should be accepted .                                                                    4pm, 7:38pm, 23:42, 3:16, 3:16am 7.Implement a parser for the BNF grammar in Exercise 6 using  yacc, bison,  or a  similar parser-generator  .8.Implement the time parser using Perl. [Hint: Regular expressions make good  parsers.] I l@ve RuBoard    I l@ve RuBoard   EstimatingQuick! How long will it take to send War and Peace over a 56k modem line? How much disk space will you need for a million names and addresses? How long does a 1,000-byte block take to pass through a router? How many months will it take to deliver your project?At one level, these are all meaningless questionsthey are all missing information. Andyet they can all be answered, as long as you are comfortable estimating. And, in theprocess of producing an estimate, you'll come to understand more about the world yourprograms inhabit.By learning to estimate, and by developing this skill to the point where you have an intuitive feel for the magnitudes of things, you will be able to show an apparent magical ability to determine their feasibility. When someone says "we'll send the backup over an ISDN line to the central site," you'll be able to know intuitively whether this is practical. When you're coding, you'll be able to know which subsystems need optimizing and which ones can be left alone.Tip 18Estimate to Avoid SurprisesAs a bonus, at the end of this section we'll reveal the single correct answer to give whenever anyone asks you for an estimate.How Accurate Is Accurate Enough?To some extent, all answers are estimates. It's just that some are more accurate than others. So the first question you have to ask yourself when someone asks you for an estimate is the context in which your answer will be taken. Do they need high accuracy, or are they looking for a ballpark figure?If your grandmother asks when you will arrive, she's probably wondering whether to     to the overall model. At this stage, simply identify each parameter.Give Each Parameter a ValueOnce you have the parameters broken out, you can go through and assign each one a value. You expect to introduce some errors in this step. The trick is to work out which parameters have the most impact on the result, and concentrate on getting them about right. Typically, parameters whose values are added into a result are less significant than those that are multiplied or divided. Doubling a line speed may double the amount of data received in an hour, while adding a 5 ms transit delay will have no noticeable effect.You should have a justifiable way of calculating these critical parameters. For the queuing example, you might want to measure the actual transaction arrival rate of the existing system, or find a similar system to measure. Similarly, you could measure the current time taken to serve a request, or come up with an estimate using the techniques described in this section. In fact, you'll often find yourself basing an estimate on other subestimates. This is where your largest errors will creep in.Calculate the AnswersOnly in the simplest of cases will an estimate have a single answer. You might be happy to say "I can walk five cross-town blocks in 15 minutes." However, as the systems get more complex, you'll want to hedge your answers. Run multiple calculations, varying the values of the critical parameters, until you work out which ones really drive the model. A spreadsheet can be a big help. Then couch your answer in terms of these parameters. "The response time is roughly three quarters of a second if the system has a SCSI bus and 64MB memory, and one second with 48MB memory." (Notice how "three quarters of a second" conveys a different feeling of accuracy than 750 ms.)During the calculation phase, you may start getting answers that seem strange. Don't be too quick to dismiss them. If your arithmetic is correct, your understanding of the problem or your model is probably wrong. This is valuable information.Keep Track of Your Estimating ProwessWe think it's a great idea to record your estimates so you can see how close you were. Ifan overall estimate involved calculating subestimates, keep track of these as well. Oftenyou'll find your estimates are pretty goodin fact, after a while, you'll come to expect this. When an estimate turns out wrong, don't just shrug and walk away. Find out why it differed from your guess. Maybe you chose some parameters that didn't match the reality of the problem. Maybe your model was wrong. Whatever the reason, take some time to uncover what happened. If you do, your next estimate will be better.Estimating Project SchedulesThe normal rules of estimating can break down in the face of the complexities and vagaries of a sizable application development. We find that often the only way to determine the timetable for a project is by gaining experience on that same project. This needn't be a paradox if you practice incremental development, repeating the following steps.Check requirements Analyze risk Design, implement, integrate Validate with the users Initially, you may have only a vague idea of how many iterations will be required, or how long they may be. Some methods require you to nail this down as part of the initial plan, but for all but the most trivial of projects this is a mistake. Unless you are doing an application similar to a previous one, with the same team and the same technology, you'd just be guessing.So you complete the coding and testing of the initial functionality and mark this as the end of the first increment. Based on that experience, you can refine your initial guess on the number of iterations and what can be included in each. The refinement gets better and better each time, and confidence in the schedule grows along with it.Tip 19Iterate the Schedule with the CodeThis may not be popular with management, who typically want a single, hard-and-fast   I l@ve RuBoard   Chapter 3. The Basic ToolsEvery craftsman starts his or her journey with a basic set of good-quality tools. A woodworker might need rules, gauges, a couple of saws, some good planes, fine chisels, drills and braces, mallets, and clamps. These tools will be lovingly chosen, will be built to last, will perform specific jobs with little overlap with other tools, and, perhaps most importantly, will feel right in the budding woodworker's hands.Then begins a process of learning and adaptation. Each tool will have its own personalityand quirks, and will need its own special handling. Each must be sharpened in a uniqueway, or held just so. Over time, each will wear according to use, until the grip looks like amold of the woodworker's hands and the cutting surface aligns perfectly with the angle atwhich the tool is held. At this point, the tools become conduits from the craftsman's brain tothe finished productthey have become extensions of his or her hands. Over time, thewoodworker will add new tools, such as biscuit cutters, laser-guided miter saws, dovetailjigsall wonderful pieces of technology. But you can bet that he or she will be happiestwith one of those original tools in hand, feeling the plane sing as it slides through the wood.Tools amplify your talent. The better your tools, and the better you know how to use them, the more productive you can be. Start with a basic set of generally applicable tools. As you gain experience, and as you come across special requirements, you'll add to this basic set. Like the craftsman, expect to add to your toolbox regularly. Always be on the lookout for better ways of doing things. If you come across a situation where you feel your current tools can't cut it, make a note to look for something different or more powerful that would have helped. Let need drive your acquisitions.Many new programmers make the mistake of adopting a single power tool, such as a particular integrated development environment (IDE), and never leave its cozy interface. This really is a mistake. We need to be comfortable beyond the limits imposed by an IDE. The only way to do this is to keep the basic tool set sharp and ready to use.In this chapter we'll talk about investing in your own basic toolbox. As with any good discussion on tools, we'll start (in The Power of Plain Text) by looking at your raw materials, the stuff you'll be shaping. From there we'll move to the workbench, or in our case the computer. How can you use your computer to get the most out of the tools you use? We'll discuss this in Shell Games. Now that we have material and a bench to work on, we'll turn to the tool you'll probably use more than any other, your editor. In Power  Editing, we'll suggest ways of making you more efficient.To ensure that we never lose any of our precious work, we should always use a Source Code Control systemeven for things such as our personal address book! And, since Mr.Murphy was really an optimist after all, you can't be a great programmer until you becomehighly skilled at Debugging.You'll need some glue to bind much of the magic together. We discuss some possibilities, such as awk, Perl, and Python, in Text Manipulation.Just as woodworkers sometimes build jigs to guide the construction of complex pieces, programmers can write code that itself writes code. We discuss this in Code Generators.Spend time learning to use these tools, and at some point you'll be surprised to discover your fingers moving over the keyboard, manipulating text without conscious thought. The tools will have become extensions of your hands.I l@ve RuBoard    I l@ve RuBoard   The Power of Plain TextAs Pragmatic Programmers, our base material isn't wood or iron, it's knowledge. We gather requirements as knowledge, and then express that knowledge in our designs, implementations, tests, and documents. And we believe that the best format for storing knowledge persistently is plain text. With plain text, we give ourselves the ability to manipulate knowledge, both manually and programmatically, using virtually every tool at our disposal.What Is Plain Text?Plain text is made up of printable characters in a form that can be read and understood directly by people. For example, although the following snippet is made up of printable characters, it is meaningless.                                        Fieldl9=467abeThe reader has no idea what the significance of 467abe may be. A better choice would be to make it understandable to humans.                                        DrawingType=UMLActivityDrawingPlain text doesn't mean that the text is unstructured; XML, SGML, and HTML are great examples of plain text that has a well-defined structure. You can do everything with plain text that you could do with some binary format, including versioning.Plain text tends to be at a higher level than a straight binary encoding, which is usually derived directly from the implementation. Suppose you wanted to store a property called uses_menus that can be either TRUE or FALSE. Using text, you might write this as                                        myprop.uses_menus=FALSEContrast this with 0010010101110101.The problem with most binary formats is that the context necessary to understand the data  is separate from the data itself. You are artificially divorcing the data from its meaning. The data may as well be encrypted; it is absolutely meaningless without the application logic to parse it. With plain text, however, you can achieve a self-describing data stream that is independent of the application that created it.Tip 20Keep Knowledge in Plain TextDrawbacksThere are two major drawbacks to using plain text: (1) It may take more space to store than a compressed binary format, and (2) it may be computationally more expensive to interpret and process a plain text file.Depending on your application, either or both of these situations may be unacceptableforexample, when storing satellite telemetry data, or as the internal format of a relationaldatabase.But even in these situations, it may be acceptable to store metadata about the raw data in plain text (see Metaprogramming ).Some developers may worry that by putting metadata in plain text, they're exposing it to the system's users. This fear is misplaced. Binary data may be more obscure than plain text, but it is no more secure. If you worry about users seeing passwords, encrypt them. If you don't want them changing configuration parameters, include a secure hash[1]  of all theparameter values in the file as a checksum. [1] MD5 is often used for this purpose. For an excellent introduction to the wonderful world ofcryptography, see [Sch95 ].The Power of TextSince larger and slower aren't the most frequently requested features from users, why bother with plain text? What are the benefits? Insurance against obsolescence Leverage Easier testing Insurance Against ObsolescenceHuman-readable forms of data, and self-describing data, will outlive all other forms of data and the applications that created them. Period.As long as the data survives, you will have a chance to be able to use itpotentially longafter the original application that wrote it is defunct.You can parse such a file with only partial knowledge of its format; with most binary files, you must know all the details of the entire format in order to parse it successfully.Consider a data file from some legacy system[2]  that you are given. You know little aboutthe original application; all that's important to you is that it maintained a list of clients' Social Security numbers, which you need to find and extract. Among the data, you see [2] All software becomes legacy as soon as it's written.                                                    <FIELD10>123-45-6789</FIELD10>    ...    <FIELD10>567-89-0123</FIELD10>    ...    <FIELD10>901-23-4567</FIELD10>Recognizing the format of a Social Security number, you can quickly write a small programto extract that dataeven if you have no information on anything else in the file.But imagine if the file had been formatted this way instead:                                                    AC27123456789B11P    ...    XY43567890123QTYL    ...    6T2190123456788AM You may not have recognized the significance of the numbers quite as easily. This is the difference between human readable and human understandable.While we're at it, FIELD10 doesn't help much either. Something like                                                    <SSNO>123-45-6789</SSNO>makes the exercise a no-brainerand ensures that the data will outlive any project thatcreated it.LeverageVirtually every tool in the computing universe, from source code management systems to compiler environments to editors and stand-alone filters, can operate on plain text.The Unix PhilosophyUnix is famous for being designed around the philosophy of small, sharp tools,each intended to do one thing well. This philosphy is enabled by using acommon underlying formatthe line-oriented, plain text file. Databases used forsystem administration (users and passwords, networking configuration, and soon) are all kept as plain text files. (some systems, such as Solaris, also maintaina binary forms of certain databases as a performance optimization. The plain textversion is kept as an interface to the binary version.)When a system crashes, you may be faced with only a minimal environment to restore it (You may not be able to access graphics drivers, for instance), Situations such as this can really make you appreciate the simplicity of plain text.For instance, suppose you have a production deployment of a large application with a complex site-specific configuration file (sendmail comes to mind). If this file is in plain text, you could place it under a source code control system (see Source Code Control ), so that you automatically keep a history of all changes. File comparison tools such as diff and fcallow you to see at a glance what changes have been made, while sum allows you to generate a checksum to monitor the file for accidental (or malicious) modification. Easier TestingIf you use plain text to create synthetic data to drive system tests, then it is a simple matter to add, update, or modify the test data without having to create any special tools to do so. Similarly, plain text output from regression tests can be trivially analyzed (with diff, for instance) or subjected to more thorough scrutiny with Perl, Python, or some other scripting tool.Lowest Common DenominatorEven in the future of XML-based intelligent agents that travel the wild and dangerous Internet autonomously, negotiating data interchange among themselves, the ubiquitous text file will still be there. In fact, in heterogeneous environments the advantages of plain text can outweigh all of the drawbacks. You need to ensure that all parties can communicate using a common standard. Plain text is that standard.Related sections include:Source Code Control Code Generators Metaprogramming Blackboards Ubiquitous Automation It's All Writing ChallengesDesign a small address book database (name, phone number, and so on) using a straightforward binary representation in your language of choice. Do this before reading the rest of this challenge.Translate that format into a plain text format using XML.1.For each version, add a new, variable-length field called directions in which 2.  you might enter directions to each person's house.What issues come up regarding versioning and extensibility? Which form was easier to modify? What about converting existing data?I l@ve RuBoard       compatibility layer for Windows, Cygwin comes with a collection of more than 120 Unix utilities, including such favorites as 1s, grep, and find. The utilities and libraries may be downloaded and used for free, but be sure to read their license.[3]  The Cygwin distributioncomes with the Bash shell. [3] The GNU General Public License [URL 57 ] is a kind of legal virus that Open Source developers use toprotect their (and your) rights. You should spend some time reading it. In essence, it says that you canuse and modify GPL'd software, but if you distribute any modifications they must be licensed according tothe GPL (and marked as such), and you must make source available. That's the virus partwheneveryou derive a work from a GPL'd work, your derived work must also be GPL'd. However, it does not limityou in any way when simply using the toolsthe ownership and licensing of software developed usingthe tools are up to you.Using Unix Tools Under WindowsWe love the availability of high-quality Unix tools under Windows, and use them daily. However, be aware that there are integration issues. Unlike their Ms-dos counterparts, these utilities are sensitive to the case of filenames, so ls a*.batwon't find AUTOEXEC.BAT. You may also come across problems with filenames containing spaces, and with differences in path separators. Finally, there are interesting problems when running Ms-dos programs that expect Ms-DOS-style arguments under the Unix shells, For examples, the Java utilities from JavaSoft use a colon as their CLASSPATH separators under Unix, but use a semicolon under MS-DOS. As a result, a Bash or ksh script that runs on a Unix box will run identically under Windows, but the command line it passes to Java will be interpreted incorrectly.Alternatively, David Korn (of Korn shell fame) has put together a package called uwin. Thishas the same aims as the Cygwin distributionit is a Unix development environment underWindows. UWIN comes with a version of the Korn shell. Commercial versions are availablefrom Global Technologies, Ltd. [URL 30 ]. In addition, AT&T allows free downloading of the package for evaluation and academic use. Again, read their license before using.Finally, Tom Christiansen is (at the time of writing) putting together Perl Power Tools, an attempt to implement all the familiar Unix utilities portably, in Perl [URL 32 ],Related sections include:Ubiquitous Automation   I l@ve RuBoard   Power EditingWe've talked before about tools being an extension of your hand. Well, this applies to editors more than to any other software tool. You need to be able to manipulate text as effortlessly as possible, because text is the basic raw material of programming. Let's look at some common features and functions that help you get the most from your editing environment.One EditorWe think it is better to know one editor very well, and use it for all editing tasks: code, documentation, memos, system administration, and so on. Without a single editor, you face a potential modern day Babel of confusion. You may have to use the built-in editor in each language's IDE for coding, and an all-in-one office product for documentation, and maybe a different built-in editor for sending e-mail. Even the keystrokes you use to edit command lines in the shell may be different.[4]  It is difficult to be proficient in any of theseenvironments if you have a different set of editing conventions and commands in each. [4] Ideally, the shell you use should have keybindings that match the ones used by your editor. Bash, forinstance, supports both vi and emacs keybindings.You need to be proficient. Simply typing linearly and using a mouse to cut and paste is not enough. You just can't be as effective that way as you can with a powerful editor under your fingers. Typing   or   ten times to move the cursor left to the beginning of a line isn't as efficient as typing a single key such as     or  .Tip 22Use a Single Editor WellChoose an editor, know it thoroughly, and use it for all editing tasks. If you use a single  editor (or set of keybindings) across all text editing activities, you don't have to stop and think to accomplish text manipulation: the necessary keystrokes will be a reflex. The editor will be an extension of your hand; the keys will sing as they slice their way through text and thought. That's our goal.Make sure that the editor you choose is available on all platforms you use. Emacs, vi, CRiSP, Brief, and others are available across multiple platforms, often in both GUI and non-GUI (text screen) versions.Editor FeaturesBeyond whatever features you find particularly useful and comfortable, here are some basic abilities that we think every decent editor should have. If your editor falls short in any of these areas, then this may be the time to consider moving on to a more advanced one.Configurable.   All aspects of the editor should be configurable to yourpreferences, including fonts, colors, window sizes, and keystroke bindings (which keys perform what commands). Using only keystrokes for common editing operations is more efficient than mouse or menu-driven commands, because your hands never leave the keyboard. Extensible.   An editor shouldn't be obsolete just because a new programminglanguage comes out. It should be able to integrate with whatever compiler environment you are using. You should be able to "teach" it the nuances of any new language or text format (XML, HTML version 9, and so on). Programmable.   You should be able to program the editor to perform complex,multistep tasks. This can be done with macros or with a built-in scripting programming language (Emacs uses a variant of Lisp, for instance). In addition, many editors support features that are specific to a particular programming language, such as:Syntax highlighting Auto-completion Auto-indentation Initial code or document boilerplate   Name of the class or module filled in (derived from the filename) Your name and/or copyright statements Skeletons for constructs in that language (constructor and destructor declarations, for example) Another useful feature is auto-indenting. Rather than having to indent manually (by using space or tab), the editor automatically indents for you at the appropriate time (after typing an open brace, for example). The nice part about this feature is that you can use the editor to provide a consistent indentation style for your project.[5] [5] The Linux kernel is developed this way. Here you have geographically dispersed developers, manyworking on the same pieces of code. There is a published list of settings (in this case, for Emacs) that describes the required indentation style.Where to Go from HereThis sort of advice is particularly hard to write because virtually every reader is at a different level of comfort and expertise with the editor(s) they are currently using. So, to summarize, and to provide some guidance on where to go next, find yourself in the left-hand column of the chart, and look at the right-hand column to see what we think you should do.If this sounds like youThen think aboutI use only basic features of many different editors.Pick a powerful editor and learn it well.I have a favorite editor, but I don't use all of its features.Learn them. Cut down the number of keystrokes you need to type.I have a favorite editor and use it where possible.Try to expand and use it for more tasks than you do already.I think you are nuts. Notepad is the best editor ever made.As long as you are happy and productive, go for it! But if you find yourself subject to "editor envy," you may need to reevaluate your position.What Editors Are Available?Having recommended that you master a decent editor, which one do we recommend? Well, we're going to duck that question; your choice of editor is a personal one (some would even say a religious one!). However, in Appendix A , we list a number of popular  editors and where to get them.ChallengesSome editors use full-blown languages for customization and scripting. Emacs, for example, uses Lisp. As one of the new languages you are going to learn this year, learn the language your editor uses. For anything you find yourself doing repeatedly, develop a set of macros (or equivalent) to handle it. Do you know everything your editor is capable of doing? Try to stump your colleagues who use the same editor. Try to accomplish any given editing task in as few keystrokes as possible. I l@ve RuBoard    I l@ve RuBoard   Source Code ControlProgress, far from consisting in change, depends on retentiveness. Those who cannot remember the past are condemned to repeat it.George Santayana, Life of ReasonOne of the important things we look for in a user interface is the   keya singlebutton that forgives us our mistakes. It's even better if the environment supports multiplelevels of undo and redo, so you can go back and recover from something that happened acouple of minutes ago. But what if the mistake happened last week, and you've turned yourcomputer on and off ten times since then? Well, that's one of the many benefits of using asource code control system: it's a giant   keya project-wide time machine thatcan return you to those halcyon days of last week, when the code actually compiled andran.Source code control systems, or the more widely scoped configuration managementsystems, keep track of every change you make in your source code and documentation. The better ones can keep track of compiler and OS versions as well. With a properly configured source code control system, you can always go back to a previous version of your software.But a source code control system (SCCS[6]  ) does far more than undo mistakes. A goodSCCS will let you track changes, answering questions such as: Who made changes in this line of code? What's the difference between the current version and last week's? How many lines of code did we change in this release? Which files get changed most often? This kind of information is invaluable for bug-tracking, audit, performance, and quality purposes. [6] We use the uppercase SCCS to refer to generic source code control systems. There is also a specificsystem called "sccs," originally released with AT&T System V Unix.An SCCS will also let you identify releases of your software. Once identified, you will always be able to go back and regenerate the release, independent of changes that may have occurred later.We often use an SCCS to manage branches in the development tree. For example, once  you have released some software, you'll normally want to continue developing for the next release. At the same time, you'll need to deal with bugs in the current release, shipping fixed versions to clients. You'll want these bug fixes rolled into the next release (if appropriate), but you don't want to ship code under development to clients. With an SCCS you can generate branches in the development tree each time you generate a release. You apply bug fixes to code in the branch, and continue developing on the main trunk. Since the bug fixes may be relevant to the main trunk as well, some systems allow you to merge selected changes from the branch back into the main trunk automatically.Source code control systems may keep the files they maintain in a central repositoryagreat candidate for archiving.Finally, some products may allow two or more users to be working concurrently on the same set of files, even making concurrent changes in the same file. The system then manages the merging of these changes when the files are sent back to the repository. Although seemingly risky, such systems work well in practice on projects of all sizes.Tip 23Always Use Source Code ControlAlways. Even if you are a single-person team on a one-week project. Even if it's a "throw-away" prototype. Even if the stuff you're working on isn't source code. Make sure that everything is under source code controldocumentation, phone number lists, memosto vendors, makefiles, build and release procedures, that little shell script that burns the CDmastereverything. We routinely use source code control on just about everything wetype (including the text of this book). Even if we're not working on a project, our day-to-daywork is secured in a repository.Source Code Control and BuildsThere is a tremendous hidden benefit in having an entire project under the umbrella of a source code control system: you can have product builds that are automatic and repeatable. The project build mechanism can pull the latest source out of the repository automatically.It can run in the middle of the night after everyone's (hopefully) gone home. You can runautomatic regression tests to ensure that the day's coding didn't break anything. Theautomation of the build ensures consistencythere are no manual procedures, and youwon't need developers remembering to copy code into some special build area.The build is repeatable because you can always rebuild the source as it existed on a given date.I l@ve RuBoard    I l@ve RuBoard   But My Team Isn't Using Source Code ControlShame on them! Sounds like an opportunity to do some evangelizing! However, while you wait for them to see the light, perhaps you should implement your own private source control. Use one of the freely available tools we list in Appendix A , and make a point of keeping your personal work safely tucked into a repository (as well as doing whatever your project requires). Although this may seem to be duplication of effort, we can pretty much guarantee it will save you grief (and save your project money) the first time you need to answer questions such as "What did you do to the xyz module?" and "What broke the build?" This approach may also help convince your management that source code control really works.Don't forget that an SCCS is equally applicable to the things you do outside of work.I l@ve RuBoard    I l@ve RuBoard   Source Code Control ProductsAppendix A , gives URLs for representative source code control systems, some commercialand others freely available. And many more products are availablelook for pointers to theconfiguration management FAQ.Related sections include:Orthogonality The Power of Plain Text It's All Writing ChallengesEven if you are not able to use an SCCS at work, install RCS or CVS on a personal system. Use it to manage your pet projects, documents you write, and (possibly) configuration changes applied to the computer system itself. Take a look at some of the Open Source projects for which publicly accessible archives are available on the Web (such as Mozilla [URL 51 ], KDE [URL 54 ], and the Gimp [URL 55 ]). How do you get updates of the source? How do you makechangesdoes the project regulate access or arbitrate the inclusion of changes? I l@ve RuBoard    I l@ve RuBoard   DebuggingIt is a painful thingTo look at your own trouble and knowThat you yourself and no one else has made itSophocles, AjaxThe word bug has been used to describe an "object of terror" ever since the fourteenth century. Rear Admiral Dr. Grace Hopper, the inventor of COBOL, is credited with observing the first computer bugliterally, a moth caught in a relay in an early computersystem. When asked to explain why the machine wasn't behaving as intended, atechnician reported that there was "a bug in the system," and dutifully taped itwings andallinto the log book.Regrettably, we still have "bugs" in the system, albeit not the flying kind. But the fourteenthcentury meaninga bogeymanis perhaps even more applicable now than it was then.Software defects manifest themselves in a variety of ways, from misunderstoodrequirements to coding errors. Unfortunately, modern computer systems are still limited todoing what you tell them to do, not necessarily what you want them to do.No one writes perfect software, so it's a given that debugging will take up a major portion of your day. Let's look at some of the issues involved in debugging and some general strategies for finding elusive bugs.Psychology of DebuggingDebugging itself is a sensitive, emotional subject for many developers. Instead of attacking it as a puzzle to be solved, you may encounter denial, finger pointing, lame excuses, or just plain apathy.Embrace the fact that debugging is just problem solving, and attack it as such.Having found someone else's bug, you can spend time and energy laying blame on the filthy culprit who created it. In some workplaces this is part of the culture, and may be  cathartic. However, in the technical arena, you want to concentrate on fixing the problem,not the blame.Tip 24Fix the Problem, Not the BlameIt doesn't really matter whether the bug is your fault or someone else's. It is still your problem.A Debugging MindsetThe easiest person to deceive is one's selfEdward Bulwer-Lytton, The DisownedBefore you start debugging, it's important to adopt the right mindset. You need to turn off many of the defenses you use each day to protect your ego, tune out any project pressures you may be under, and get yourself comfortable. Above all, remember the first rule of debugging:Tip 25Don't PanicIt's easy to get into a panic, especially if you are facing a deadline, or have a nervous boss or client breathing down your neck while you are trying to find the cause of the bug. But it is very important to step back a pace, and actually think about what could be causing the symptoms that you believe indicate a bug.If your first reaction on witnessing a bug or seeing a bug report is "that's impossible," you are plainly wrong. Don't waste a single neuron on the train of thought that begins "but that  can't happen" because quite clearly it can, and has.Beware of myopia when debugging. Resist the urge to fix just the symptoms you see: it is more likely that the actual fault may be several steps removed from what you are observing, and may involve a number of other related things. Always try to discover the root cause of a problem, not just this particular appearance of it.Where to StartBefore you start to look at the bug, make sure that you are working on code that compiledcleanlywithout warnings. We routinely set compiler warning levels as high as possible. Itdoesn't make sense to waste time trying to find a problem that the compiler could find foryou! We need to concentrate on the harder problems at hand.When trying to solve any problem, you need to gather all the relevant data. Unfortunately, bug reporting isn't an exact science. It's easy to be misled by coincidences, and you can't afford to waste time debugging coincidences. You first need to be accurate in your observations.Accuracy in bug reports is further diminished when they come through a third partyyoumay actually need to watch the user who reported the bug in action to get a sufficient level of detail.Andy once worked on a large graphics application. Nearing release, the testers reported that the application crashed every time they painted a stroke with a particular brush. The programmer responsible argued that there was nothing wrong with it; he had tried painting with it, and it worked just fine. This dialog went back and forth for several days, with tempers rapidly rising.Finally, we got them together in the same room. The tester selected the brush tool and painted a stroke from the upper right corner to the lower left corner. The application exploded. "Oh," said the programmer, in a small voice, who then sheepishly admitted that he had made test strokes only from the lower left to the upper right, which did not expose the bug.There are two points to this story:You may need to interview the user who reported the bug in order to gather more data than you were initially given.   page. As you single-step through your program, pictures like these can be worth much more than a thousand words, as the bug you've been hunting suddenly jumps out at you. Figure 3.2. Sample debugger diagram of a circular linked list. The arrows represent pointers to nodes. Even if your debugger has limited support for visualizing data, you can still do ityourselfeither by hand, with paper and pencil, or with external plotting programs.The DDD debugger has some visualization capabilities, and is freely available (see [URL  19 ]). It is interesting to note that DDD works with multiple languages, including Ada, C, C++, Fortran, Java, Modula, Pascal, Perl, and Python (clearly an orthogonal design).TracingDebuggers generally focus on the state of the program now. Sometimes you needmoreyou need to watch the state of a program or a data structure over time. Seeing astack trace can only tell you how you got here directly. It can't tell you what you were doingprior to this call chain, especially in event-based systems.Tracing statements are those little diagnostic messages you print to the screen or to a file that say things such as "got here" and "value of x = 2." It's a primitive technique compared with IDE-style debuggers, but it is peculiarly effective at diagnosing several classes of errors that debuggers can't. Tracing is invaluable in any system where time itself is a factor: concurrent processes, real-time systems, and event-based applications.You can use tracing statements to "drill down" into the code. That is, you can add tracing statements as you descend the call tree.Trace messages should be in a regular, consistent format; you may want to parse them  automatically. For instance, if you needed to track down a resource leak (such as unbalanced file opens/closes), you could trace each open and each close in a log file. By processing the log file with Perl, you could easily identify where the offending open was occurring.Corrupt Variables? Check Their NeighborhoodSometimes you'll examine a variable, expecting to see a small integer value, and instead get something like 0x6e69614d. Before you roll up your sleeves for some serious debugging, have a quick look at the memory around this corrupted variable. Often it will give you a clue. In our case, examining the surrounding memory as characters shows us                                                            20333231 6e69614d 2c745320 746f4e0a     1 2 3    M a i n    S t , \n N o t    2c6e776f 2058580a 31323433 00000a33     o w n , \n x x    3 4 2 1  3\n\0\0Looks like someone sprayed a street address over our counter. Now we know where to look.Rubber DuckingA very simple but particularly useful technique for finding the cause of a problem is simply to explain it to someone else. The other person should look over your shoulder at the screen, and nod his or her head constantly (like a rubber duck bobbing up and down in a bathtub). They do not need to say a word; the simple act of explaining, step by step, what the code is supposed to do often causes the problem to leap off the screen and announce itself.[7] [7] Why "rubber ducking"? While an undergraduate at Imperial College in London, Dave did a lot of workwith a research assistant named Greg Pugh, one of the best developers Dave has known. For several months Greg carried around a small yellow rubber duck, which he'd place on his terminal while coding. It was a while before Dave had the courage to ask....It sounds simple, but in explaining the problem to another person you must explicitly state things that you may take for granted when going through the code yourself. By having to    Also, if the bug is the result of bad data that was propagated through a couple of levels before causing the explosion, see if better parameter checking in those routines would have isolated it earlier (see the discussions on crashing early and assertions on pages 120 and 122, respectively).While you're at it, are there any other places in the code that may be susceptible to this same bug? Now is the time to find and fix them. Make sure that whatever happened, you'll know if it happens again.If it took a long time to fix this bug, ask yourself why. Is there anything you can do to make fixing this bug easier the next time around? Perhaps you could build in better testing hooks, or write a log file analyzer.Finally, if the bug is the result of someone's wrong assumption, discuss the problem with the whole team: if one person misunderstands, then it's possible many people do.Do all this, and hopefully you won't be surprised next time.Debugging ChecklistIs the problem being reported a direct result of the underlying bug, or merely a symptom? Is the bug really in the compiler? Is it in the OS? Or is it in your code? If you explained this problem in detail to a coworker, what would you say? If the suspect code passes its unit tests, are the tests complete enough? What happens if you run the unit test with this data? Do the conditions that caused this bug exist anywhere else in the system? Related sections include:Assertive Programming Programming by Coincidence Ubiquitous Automation  Ruthless Testing ChallengesDebugging is challenge enough. I l@ve RuBoard    I l@ve RuBoard   Text ManipulationPragmatic Programmers manipulate text the same way woodworkers shape wood. Inprevious sections we discussed some specific toolsshells, editors, debuggersthat weuse. These are similar to a wood-worker's chisels, saws, and planestools specialized todo one or two jobs well. However, every now and then we need to perform sometransformation not readily handled by the basic tool set. We need a general-purpose textmanipulation tool.Text manipulation languages are to programming what routers[8]  are to woodworking. Theyare noisy, messy, and somewhat brute force. Make mistakes with them, and entire pieces can be ruined. Some people swear they have no place in the toolbox. But in the right hands, both routers and text manipulation languages can be incredibly powerful and versatile. You can quickly trim something into shape, make joints, and carve. Used properly, these tools have surprising finesse and subtlety. But they take time to master. [8] Here router means the tool that spins cutting blades very, very fast, not a device for interconnecting networks.There is a growing number of good text manipulation languages. Unix developers often like to use the power of their command shells, augmented with tools such as awk and sed.People who prefer a more structured tool like the object-oriented nature of Python [URL 9 ]. Some people use Tcl [URL 23 ] as their tool of choice. We happen to prefer Perl [URL 8 ] for hacking out short scripts.These languages are important enabling technologies. Using them, you can quickly hackup utilities and prototype ideasjobs that might take five or ten times as long usingconventional languages. And that multiplying factor is crucially important to the kind ofexperimenting that we do. Spending 30 minutes trying out a crazy idea is a whole lot betterthat spending five hours. Spending a day automating important components of a project isacceptable; spending a week might not be. In their book The Practice of Programming[KP99 ], Kernighan and Pike built the same program in five different languages. The Perl version was the shortest (17 lines, compared with C's 150). With Perl you can manipulate text, interact with programs, talk over networks, drive Web pages, perform arbitrary precision arithmetic, and write programs that look like Snoopy swearing.Tip 28 Learn a Text Manipulation LanguageTo show the wide-ranging applicability of text manipulation languages, here's a sample of some applications we've developed over the last few years.Database schema maintenance.   A set of Perl scripts took a plain text filecontaining a database schema definition and from it generated:The SQL statements to create the database Flat data files to populate a data dictionary C code libraries to access the database Scripts to check database integrity Web pages containing schema descriptions and diagrams An XML version of the schema Java property access.   It is good OO programming style to restrict access to anobject's properties, forcing external classes to get and set them via methods. However, in the common case where a property is represented inside the class by a simple member variable, creating a get and set method for each variable is tedious and mechanical. We have a Perl script that modifies the source files and inserts the correct method definitions for all appropriately flagged variables. Test data generation.   We had tens of thousands of records of test data, spreadover several different files and formats, that needed to be knitted together and converted into a form suitable for loading into a relational database. Perl did it in a couple of hours (and in the process found a couple of consistency errors in the original data). Book writing.   We think it is important that any code presented in a book shouldhave been tested first. Most of the code in this book has been. However, using the DRY principle (see The Evils of Duplication ) we didn't want to copy and paste linesof code from the tested programs into the book. That would have meant that the    .p1  flies in a directory and adds a  use strict  at the end of the initial comment  block to all flies that don't already have one. Remember to keep a backup of  all flies you change  .I l@ve RuBoard    I l@ve RuBoard   Code GeneratorsWhen woodworkers are faced with the task of producing the same thing over and over, they cheat. They build themselves a jig or a template. If they get the jig right once, they can reproduce a piece of work time after time. The jig takes away complexity and reduces the chances of making mistakes, leaving the craftsman free to concentrate on quality.As programmers, we often find ourselves in a similar position. We need to achieve the same functionality, but in different contexts. We need to repeat information in different places. Sometimes we just need to protect ourselves from carpal tunnel syndrome by cutting down on repetitive typing.In the same way a woodworker invests the time in a jig, a programmer can build a code generator. Once built, it can be used throughout the life of the project at virtually no cost.Tip 29Write Code That Writes CodeThere are two main types of code generators:Passive code generators are run once to produce a result. From that pointforward, the result becomes freestandingit is divorced from the code generator.The wizards discussed in Evil Wizards, along with some CASE tools, are examples of passive code generators.1.Active code generators are used each time their results are required. The result isa throw-awayit can always be reproduced by the code generator. Often, activecode generators read some form of script or control file to produce their results.2.Passive Code GeneratorsPassive code generators save typing. They are basically parameterized templates,  generating a given output from a set of inputs. Once the result is produced, it becomes a full-fledged source file in the project; it will be edited, compiled, and placed under source control just like any other file. Its origins will be forgotten.Passive code generators have many uses:Creating new source files. A passive code generator can produce templates, source code control directives, copyright notices, and standard comment blocks for each new file in a project. We have our editors set up to do this whenever we create a new file: edit a new Java program, and the new editor buffer will automatically contain a comment block, package directive, and the outline class declaration, already filled in. Performing one-off conversions among programming languages. We started writing this book using the troff system, but we switched to LaTeXafter 15 sections had been completed. We wrote a code generator that read the troff source and converted it to LaTeX. It was about 90% accurate; the rest we did by hand. This is an interesting feature of passive code generators: they don't have to be totally accurate. You get to choose how much effort you put into the generator, compared with the energy you spend fixing up its output. Producing lookup tables and other resources that are expensive to compute at runtime. Instead of calculating trigonometric functions, many early graphics systems used precomputed tables of sine and cosine values. Typically, these tables were produced by a passive code generator and then copied into the source. Active Code GeneratorsWhile passive code generators are simply a convenience, their active cousins are a necessity if you want to follow the DRY principle. With an active code generator, you can take a single representation of some piece of knowledge and convert it into all the forms your application needs. This is not duplication, because the derived forms are disposable, and are generated as needed by the code generator (hence the word active).Whenever you find yourself trying to get two disparate environments to work together, you should consider using active code generators.Perhaps you're developing a database application. Here, you're dealing with twoenvironmentsthe database and the programming language you are using to access it. You have a schema, and you need to define low-level structures mirroring the layout ofcertain database tables. You could just code these directly, but this violates the DRYprinciple: knowledge of the schema would then be expressed in two places. When the schema changes, you need to remember to change the corresponding code. If a column is removed from a table, but the code base is not changed, you might not even get a compilation error. The first you'll know about it is when your tests start failing (or when the user calls).An alternative is to use an active code generatortake the schema and use it to generatethe source code for the structures, as shown in Figure 3.3 . Now, whenever the schema changes, the code used to access it also changes, automatically. If a column is removed, then its corresponding field in the structure will disappear, and any higher-level code that uses that column will fail to compile. You've caught the error at compile time, not in production. Of course, this scheme works only if you make the code generation part of the build process itself.[9] [9] Just how do you go about building code from a database schema? There are several ways. If the schema is held in a flat file (for example, as create table statements), then a relatively simple script can parse it and generate the source. Alternatively, if you use a tool to create the schema directly in the database, then you should be able to extract the information you need directly from the database's data dictionary. Perl provides libraries that give you access to most major databases. Figure 3.3. Active code generator creates code from a database schema Another example of melding environments using code generators happens when differentprogramming languages are used in the same application. In order to communicate, eachcode base will need some information in commondata structures, message formats, andfield names, for example. Rather than duplicate this information, use a code generator.Sometimes you can parse the information out of the source files of one language and use itto generate code in a second language. Often, though, it is simpler to express it in asimpler, language-neutral representation and generate the code for both languages, asshown in Figure 3.4  on the following page. Also see the answer to Exercise 13 on page 286 for an example of how to separate the parsing of the flat file representation from code  generation. Figure 3.4. Generating code from a language-neutral representation. In the input file, lines starting with 'M' flag the start of a message definition, 'F' lines define fields, and 'E' is the end of the message. Code Generators Needn't Be ComplexAll this talk of active this and passive that may leave you with the impression that code generators are complex beasts. They needn't be. Normally the most complex part is the parser, which analyzes the input file. Keep the input format simple, and the code generator becomes simple. Have a look at the answer to Exercise 13 (page 286): the actual code generation is basically print statements.Code Generators Needn't Generate CodeAlthough many of the examples in this section show code generators that produceprogram source, this needn't always be the case. You can use code generators to writejust about any output: HTML, XML, plain textany text that might be an input somewhereelse in your project.Related sections include: The Evils of Duplication The Power of Plain Text Evil Wizards Ubiquitous Automation Exercises 13.Write a code generator that takes the input file in  Figure 3.4 , and generates output in two languages of your choice. Try to make it easy to add new languages.I l@ve RuBoard     In Dead Programs Tell No Lies, we want to ensure that we do no damage while we're working the bugs out. So we try to check things often and terminate the program if things go awry.Assertive Programming describes an easy method of checking along the waywrite codethat actively verifies your assumptions.Exceptions, like any other technique, can cause more harm than good if not used properly. We'll discuss the issues in When to Use Exceptions.As your programs get more dynamic, you'll find yourself juggling systemresourcesmemory, files, devices, and the like. In How to Balance Resources, we'll suggest ways of ensuring that you don't drop any of the balls.In a world of imperfect systems, ridiculous time scales, laughable tools, and impossible requirements, let's play it safe.When everybody actually is out to get you, paranoia is just good thinking.Woody AlienI l@ve RuBoard     Preconditions.   What must be true in order for the routine to be called; theroutine's requirements. A routine should never get called when its preconditions would be violated. It is the caller's responsibility to pass good data (see the box on page 115). Postconditions.   What the routine is guaranteed to do; the state of the worldwhen the routine is done. The fact that the routine has a postcondition implies that it will conclude: infinite loops aren't allowed. Class invariants.   A class ensures that this condition is always true from theperspective of a caller. During internal processing of a routine, the invariant may not hold, but by the time the routine exits and control returns to the caller, the invariant must be true. (Note that a class cannot give unrestricted write-access to any data member that participates in the invariant.) Let's look at the contract for a routine that inserts a data value into a unique, ordered list. In iContract, a preprocessor for Java available from [URL 17 ], you'd specify it as                                            /**      * @invariant forall Node n in elements() |      *    n.prev() != null      *      implies      *         n.value().compare To(n.prev().value()) > 0      */    public class dbc_list {      /**        * @pre contains(aNode) == false        * @post contains(aNode) == true        */      public void insertNode(final Node aNode) {        // ...Here we are saying that nodes in this list must always be in increasing order. When you insert a new node, it can't exist already, and we guarantee that the node will be found after you have inserted it.You write these preconditions, postconditions, and invariants in the target programminglanguage, perhaps with some extensions. For example, iContract provides predicate logicoperatorsforall, exists, and impliesin addition to normal Java constructs. Your  Inheritance and polymorphism are the cornerstones of object-oriented languages and an area where contracts can really shine. Suppose you are using inheritance to create an "is-a-kind-of" relationship, where one class "is-a-kind-of" another class. You probably want to adhere to the Liskov Substitution Principle [Lis88 ]:Subclasses must be usable through the base class interface without the need for the user to know the difference.In other words, you want to make sure that the new subtype you have created really"is-a-klnd-of" the base typethat it supports the same methods, and that the methodshave the same meaning. We can do this with contracts. We need to specify a contract onlyonce, in the base class, to have it applied to every future subclass automatically. Asubclass may, optionally, accept a wider range of input, or make stronger guarantees. Butit must accept at least as much, and guarantee as much, as its parent.For example, consider the Java base class java.awt.Component. You can treat any visual component in AWT or Swing as a Component, without knowing that the actual subclass is a button, a canvas, a menu, or whatever. Each individual component can provide additional, specific functionality, but it has to provide at least the basic capabilities defined by Component. But there's nothing to prevent you from creating a subtype of Componentthat provides correctly named methods that do the wrong thing. You can easily create a paint method that doesn't paint, or a setFont method that doesn't set the font. AWT doesn't have contracts to catch the fact that you didn't live up to the agreement.Without a contract, all the compiler can do is ensure that a subclass conforms to a particular method signature. But if we put a base class contract in place, we can now ensure that any future subclass can't alter the meanings of our methods. For instance, you might want to establish a contract for setFont such as the following, which ensures that the font you set is the font you get:                                            /**      * @pre  f != null      * @post getFont() == f      */      public void setFont(final Font f) {       // ...Implementing DBC  Languages that feature built-in support of DBC (such as Eiffel and Sather [URL 12 ]) check pre- and postconditions automatically in the compiler and runtime system. You get the greatest benefit in this case because all of the code base (libraries, too) must honor their contracts.But what about more popular languages such as C, C++, and Java? For these languages, there are preprocessors that process contracts embedded in the original source code as special comments. The preprocessor expands these comments to code that verifies the assertions.For C and C++, you may want to investigate Nana [URL 18 ]. Nana doesn't handle inheritance, but it does use the debugger at runtime to monitor assertions in a novel way.For Java, there is iContract [URL 17 ]. It takes comments (in JavaDoc form) and generates a new source file with the assertion logic included.Preprocessors aren't as good as a built-in facility. They can be messy to integrate into yourproject, and other libraries you use won't have contracts. But they can still be very helpful;when a problem is discovered this wayespecially one that you would never havefoundit's almost like magic.DBC and Crashing EarlyDBC fits in nicely with our concept of crashing early (see Dead Programs Tell No Lies ). Suppose you have a method that calculates square roots (such as in the Eiffel class DOUBLE). It needs a precondition that restricts the domain to positive numbers. An Eiffel precondition is declared with the keyword require, and a postcondition is declared with ensure, so you could write                                                sqrt: DOUBLE is              -- Square root routine           require              sqrt_arg_must_be_positive: Current >= 0;           --- ...           --- calculate square root here           --- ...           ensure              ((Result*Result) - Current).abs <= epsilon*Current.abs;  problem.Other Uses of InvariantsSo far we have discussed pre- and postconditions that apply to individual methods and invariants that apply to all methods within a class, but there are other useful ways to use invariants.Loop InvariantsGetting the boundary conditions right on a nontrMal loop can be problematic. Loops are subject to the banana problem (I know how to spell "banana," but I don't know when to stop), fencepost errors (not knowing whether to count the fenceposts or the spaces between them), and the ubiquitous "off by one" error [URL 52 ].Invariants can help in these situations: a loop invariant is a statement of the eventual goal of a loop, but is generalized so that it is also valid before the loop executes and on each iteration through the loop. You can think of it as a kind of miniature contract. The classic example is a routine that finds the maximum value in an array.                                                    int m = arr[0];   // example assumes arr.length > 0    int i = 1;    // Loop invariant: m = max(arr[0:i-1])    while (i < arr.length) {      m = Math.max(m, arr[i]);      i = i + 1;    }(arr[m:n] is a notational convenience meaning a slice of the array from index m to n.) The invariant must be true before the loop runs, and the body of the loop must ensure that it remains true as the loop executes. In this way we know that the invariant also holds when the loop terminates, and therefore that our result is valid. Loop invariants can be coded explicitly as assertions, but they are also useful as design and documentation tools.Semantic InvariantsYou can use semantic invariants to express inviolate requirements, a kind of   among themselves to achieve a goal, we might just solve the software productivity crisis by letting software solve it for us.But if we can't use contracts by hand, we won't be able to use them automatically. So next time you design a piece of software, design its contract as well.Related sections include:Orthogonality Dead Programs Tell No Lies Assertive Programming How to Balance Resources Decoupling and the Law of Demeter Temporal Coupling Programming by Coincidence Code That's Easy to Test Pragmatic Teams ChallengesPoints to ponder: If DBC is so powerful, why isn't it used more widely? Is it hard to come up with the contract? Does it make you think about issues you'd rather ignore for now? Does it force you to THINK!? Clearly, this is a dangerous tool! Exercises 14.What makes a good contract? Anyone can add preconditions and  postconditions, but will they do you any good? Worse yet, will they actually do  more harm than good? For the example below and for those in Exercises 15  and 16, decide whether the specified contract is good, bad, or ugly, and       crippled one.Related sections include:Design by Contract When to Use Exceptions I l@ve RuBoard      percentage of the permutations your code will be put through (see Ruthless Testing ). Second, the optimists are forgetting that your program runs in a dangerous world. During testing, rats probably won't gnaw through a communications cable, someone playing a game won't exhaust memory, and log files won't fill the hard drive. These things might happen when your program runs in a production environment. Your first line of defense is checking for any possible error, and your second is using assertions to try to detect those you've missed.Turning off assertions when you deliver a program to production is like crossing a high wire without a net because you once made it across in practice. There's dramatic value, but it's hard to get life insurance.Even if you do have performance issues, turn off only those assertions that really hit you. The sort example above may be a critical part ofAssertion and Side EffectsIt is embarrassing when the code we add to detect errors actually ends up creatings new errors. This can happen with assertions if evaluating the condition has side effects. for example, in Java it would be a bad to code something such as                                                    while (iter.hasmoreElements () {      Test.ASSERT(iter.nextElements() != null);      object obj = iter.nextElement();      // ....    }The .nextElement() call in the ASSERT has the side effects of moving the iterator past the element being fetched, and so the loop will process only half the elements in the collection. It would be better to write                                                    while (iter.hasmoreElements()) {      object obj = iter.nextElement();      Test.ASSERT(obj != null);      //....     }This problem is a kind of "Heisenbug"debugging that changes the behavior ofthe system system being debugged (see [URL 52 ]).your application, and may need to be fast. Adding the check means another pass through the data, which might be unacceptable. Make that particular check optional,[2]  but leave therest in. [2] In C-based languages, you can either use the preprocessor or use if statements to make assertions optional. Many implementations turn off code generation for the assert macro if a compile-time flag is set (or not set). Otherwise, you can place the code within an if statement with a constant condition, which many compilers (including most common Java systems) will optimize away.Related sections include:Debugging Design by Contract How to Balance Resources Programming by Coincidence Exercises19.A quick reality check. Which of these "impossible" things can happen? A month with fewer than 28 days1.stat("." ,&sb) == -1 (that is, can't access the current directory)2.In C++: a = 2; b = 3; if (a + b != 5) exit(1);3.A triangle with an interior angle sum \u8800 180°4.A minute that doesn't have 60 seconds5. In Java: a + 1) <= a6. 20.Develop a simple assertion checking class for Java .I l@ve RuBoard    I l@ve RuBoard   When to Use ExceptionsIn Dead Programs Tell No Lies , we suggested that it is good practice to check for everypossible errorparticularly the unexpected ones. However, in practice this can lead tosome pretty ugly code; the normal logic of your program can end up being totally obscuredby error handling, particularly if you subscribe to the "a routine must have a single returnstatement" school of programming (we don't). We've seen code that looks something likethe following:                                    retcode = OK;    if (socket.read(name) != OK) {      retcode = BAD_READ;    }    else {      processName(name);      if (socket.read(address) != OK) {        retcode = BAD_READ;      }      else {        processAddress(address);        if (socket.read(telNo) != OK) {          retcode = BAD_READ;        }        else {          // etc, etc...        }      }    }    return retcode;Fortunately, if the programming language supports exceptions, you can rewrite this code in a far neater way:                                    retcode = OK;    try {   routines and their callers are more tightly coupled via exception handling.Error Handlers Are an AlternativeAn error handler is a routine that is called when an error is detected. You can register a routine to handle a specific category of errors. When one of these errors occurs, the handler will be called.There are times when you may want to use error handlers, either instead of or alongside exceptions. Clearly, if you are using a language such as C, which does not support exceptions, this is one of your few other options (see the challenge on the next page). However, sometimes error handlers can be used even in languages (such as Java) that have a good exception handling scheme built in.Consider the implementation of a client-server application, using Java's Remote Method Invocation (RMI) facility. Because of the way RMI is implemented, every call to a remote routine must be prepared to handle a RemoteException. Adding code to handle these exceptions can become tedious, and means that it is difficult to write code that works with both local and remote routines. A possible work-around is to wrap your remote objects in a class that is not remote. This class then implements an error handler interface, allowing the client code to register a routine to be called when a remote exception is detected.Related sections include:Dead Programs Tell No Lies ChallengesLanguages that do not support exceptions often have some other nonlocal transfer of control mechanism (C has longjmp/setjmp, for example). Consider how you could implement some kind of ersatz exception mechanism using these facilities. What are the benefits and dangers? What special steps do you need to take to ensure that resources are not orphaned? Does it make sense to use this kind of solution whenever you code in C? Exercises  21.While designing a new container class, you identify the following possible  error conditions :No memory available for a new element in the add routine1.Requested entry not found in the fetch routine2.null pointer passed to the add routine3.How should each be handled? Should an error be generated, should an exception be raised, or should the condition be ignored?I l@ve RuBoard           fwrite (cRec, sizeof(*cRec), 1, cFile);      fclose(cFile);    }    void updateCustomer(const char *fName, double newBalance) {      Customer cRec;      readCustomer(fName, &cRec);      cRec.balance = newBalance;      writeCustomer(&cRec);    }At first sight, the routine updateCustomer looks pretty good. It seems to implement thelogic we requirereading a record, updating the balance, and writing the record back out.However, this tidiness hides a major problem. The routines readCustomer and writeCustomer are tightly coupled[3]  they share the global variable cFile.readCustomeropens the file and stores the file pointer in cFile, and writeCustomer uses that stored pointer to close the file when it finishes. This global variable doesn't even appear in the updateCustomer routine. [3] For a discussion of the dangers of coupled code, see Decoupling and the Law of Demeter .Why is this bad? Let's consider the unfortunate maintenance programmer who is told thatthe specification has changedthe balance should be updated only if the new value is notnegative. She goes into the source and changes updateCustomer:                                    void updateCustomer(const char *fName, double newBalance) {      Customer cRec;      readCustomer(fName, &cRec);      if (newBalance >= 0.0) {        cRec.balance = newBalance;        writeCustomer(&cRec);       }    }All seems fine during testing. However, when the code goes into production, it collapses after several hours, complaining of too many open files. Because writeBalance is not getting called in some circumstances, the file is not getting closed.A very bad solution to this problem would be to deal with the special case in updateCustomer:                                    void updateCustomer(const char *fName, double newBalance) {      Customer cRec;      readCustomer(fName, &cRec);      if (newBalance >= 0.0) {        cRec.balance = newBalance;        writeCustomer(&cRec);      }      else        fclose(cFile);    }This will fix the problemthe file will now get closed regardless of the new balancebutthe fix now means that three routines are coupled through the global cFile. We're falling into a trap, and things are going to start going downhill rapidly if we continue on this course.The finish what you start tip tells us that, ideally, the routine that allocates a resource should also free it. We can apply it here by refactoring the code slightly:                                    void readCustomer(FILE *cFile, Customer *cRec) {      fread(cRec, sizeof(*cRec), 1, cFile);    }    void writeCustomer(FILE *cFile, Customer *cRec) {       rewind(cFile);      fwrite(cRec, sizeof(*cRec), 1, cFile);    }    void updateCustomer(const char *fName, double newBalance) {      FILE *cFile;      Customer cRec;      cFile = fopen(fName, "r+");      // >---      readCustomer(cFile, &cRec);        //     /      if (newBalance >= 0.0) {           //     /        cRec.balance = newBalance;       //     /        writeCustomer(cFile, &cRec);     //     /      }                                  //     /      fclose(cFile);                     // <---    }Now all the responsibility for the file is in the updateCustomer routine. It opens the file and (finishing what it starts) closes it before exiting. The routine balances the use of the file: the open and close are in the same place, and it is apparent that for every open there will be a corresponding close. The refactoring also removes an ugly global variable.Nest AllocationsThe basic pattern for resource allocation can be extended for routines that need more than one resource at a time. There are just two more suggestions:Deallocate resources in the opposite order to that in which you allocate them. That way you won't orphan resources if one resource contains references to another.1.When allocating the same set of resources in different places in your code, always allocate them in the same order. This will reduce the possibility of deadlock. (If process A claims resource1 and is about to claim resource2, while process B has claimed resource2 and is trying to get resource1, the two processes will wait forever.)2.It doesn't matter what kind of resources we're usingtransactions, memory, files, threads,windowsthe basic pattern applies: whoever allocates a resource should be responsiblefor deallocating it. However, in some languages we can develop the concept further. I l@ve RuBoard    I l@ve RuBoard   Objects and ExceptionsThe equilibrium between allocations and deallocations is reminiscent of a class's constructor and destructor. The class represents a resource, the constructor gives you a particular object of that resource type, and the destructor removes it from your scope.If you are programming in an object-oriented language, you may find it useful to encapsulate resources in classes. Each time you need a particular resource type, you instantiate an object of that class. When the object goes out of scope, or is reclaimed by the garbage collector, the object's destructor then deallocates the wrapped resource.This approach has particular benefits when you're working with languages such as C++, where exceptions can interfere with resource deallocation.I l@ve RuBoard    I l@ve RuBoard   Balancing and ExceptionsLanguages that support exceptions can make resource deallocation tricky. If an exception is thrown, how do you guarantee that everything allocated prior to the exception is tidied up? The answer depends to some extent on the language.Balancing Resources with C++ ExceptionsC++ supports a trycatch exception mechanism. Unfortunately, this means that there are always at least two possible paths when exiting a routine that catches and then rethrows an exception:                                            void doSomething(void) {      Node *n = new Node;      try {        // do something      }      catch (...) {        delete n;        throw;      }      delete n;    }Notice that the node we create is freed in two placesonce in the routine's normal exitpath, and once in the exception handler. This is an obvious violation of the DRY principle and a maintenance problem waiting to happen.However, we can use the semantics of C++ to our advantage. Local objects are automatically destroyed on exiting from their enclosing block. This gives us a couple of options. If the circumstances permit, we can change "n" from a pointer to an actual Node object on the stack:                                             void doSomething1(void) {      Node n;      try {        // do something      }      catch (...) {        throw;      }    }Here we rely on C++ to handle the destruction of the Node object automatically, whether an exception is thrown or not.If the switch from a pointer is not possible, the same effect can be achieved by wrapping the resource (in this case, a Node pointer) within another class.                                            // Wrapper class for Node resources    class NodeResource {      Node *n;     public:      NodeResource() { n = new Node; }      ~NodeResource() { delete n; }      Node *operator->() { return n; }    };    void doSomething2(void) {      NodeResource n;      try {        // do something      }      catch (...) {        throw;      }    } Now the wrapper class, NodeResource, ensures that when its objects are destroyed the corresponding nodes are also destroyed. For convenience, the wrapper provides a dereferencing operator ->, so that its users can access the fields in the contained Node object directly.Because this technique is so useful, the standard C++ library provides the template class auto_ptr, which gives you automatic wrappers for dynamically allocated objects.                                            void doSomething3(void) {      auto_ptr<Node> p (new Node);      // Access the Node as p->...      // Node automatically deleted at end    }Balancing Resources in JavaUnlike C++, Java implements a lazy form of automatic object destruction. Unreferenced objects are considered to be candidates for garbage collection, and their finalize method will get called should garbage collection ever claim them. While a convenience for developers, who no longer get the blame for most memory leaks, it makes it difficult to implement resource clean-up using the C++ scheme. Fortunately, the designers of the Java language thoughtfully added a language feature to compensate, the finally clause. When a try block contains a finally clause, code in that clause is guaranteed to be executed if any statement in the try block is executed. It doesn't matter whether an exception is thrown (or even if the code in the try block executes a return)the code in thefinally clause will get run. This means we can balance our resource usage with code such as                                            public void doSomething() throws IOException {      File tmpFile = new File(tmpFileName);      FileWriter tmp = new FileWriter(tmpFile);      try {        // do some work      }      finally {         tmpFile.delete();      }    }The routine uses a temporary file, which we want to delete, regardless of how the routine exits. The finally block allows us to express this concisely.I l@ve RuBoard    I l@ve RuBoard   When You Can't Balance ResourcesThere are times when the basic resource allocation pattern just isn't appropriate. Commonly this is found in programs that use dynamic data structures. One routine will allocate an area of memory and link it into some larger structure, where it may stay for some time.The trick here is to establish a semantic invariant for memory allocation. You need to decide who is responsible for data in an aggregate data structure. What happens when you deallocate the top-level structure? You have three main options:The top-level structure is also responsible for freeing any substructures that it contains. These structures then recursively delete data they contain, and so on.1.The top-level structure is simply deallocated. Any structures that it pointed to (that are not referenced elsewhere) are orphaned.2.The top-level structure refuses to deallocate itself if it contains any substructures.3.The choice here depends on the circumstances of each individual data structure. However, you need to make it explicit for each, and implement your decision consistently. Implementing any of these options in a procedural language such as C can be a problem: data structures themselves are not active. Our preference in these circumstances is to write a module for each major structure that provides standard allocation and deallocation facilities for that structure. (This module can also provide facilities such as debug printing, serialization, deserialization, and traversal hooks.)Finally, if keeping track of resources gets tricky, you can write your own form of limited automatic garbage collection by implementing a reference counting scheme on your dynamically allocated objects. The book More Effective C++ [Mey96 ] dedicates a section to this topic.I l@ve RuBoard    I l@ve RuBoard   Checking the BalanceBecause Pragmatic Programmers trust no one, including ourselves, we feel that it is always a good idea to build code that actually checks that resources are indeed freed appropriately. For most applications, this normally means producing wrappers for each type of resource, and using these wrappers to keep track of all allocations and deallocations. At certain points in your code, the program logic will dictate that the resources will be in a certain state: use the wrappers to check this.For example, a long-running program that services requests will probably have a single point at the top of its main processing loop where it waits for the next request to arrive. This is a good place to ensure that resource usage has not increased since the last execution of the loop.At a lower, but no less useful level, you can invest in tools that (among other things) check your running programs for memory leaks. Purify (http://www.rational.com ) and Insure++ (http://www.parasoft.com ) are popular choices.Related sections include:Design by Contract Assertive Programming Decoupling and the Law of Demeter ChallengesAlthough there are no guaranteed ways of ensuring that you always free resources, certain design techniques, when applied consistently, will help. In the text we discussed how establishing a semantic invariant for major data structures could direct memory deallocation decisions. Consider how Design by Contract , could help refine this idea. I l@ve RuBoard    I l@ve RuBoard   Exercises 22.Some C and C++ developers make a point of setting a pointer to  NULL  after  they deallocate the memory it references. Why is this a good idea? 23.Some Java developers make a point of setting an object variable to  NULL after they have finished using the object. Why is this a good idea? I l@ve RuBoard      For example, suppose you are writing a class that generates a graph of scientific recorder data. You have data recorders spread around the world; each recorder object contains a location object giving its position and time zone. You want to let your users select a recorder and plot its data, labeled with the correct time zone. You might write                                             public void plotDate(Date aDate, Selection aSelection) {       TimeZone tz =          aSelection.getRecorder().getLocation().getTimeZone();       ...     }But now the plotting routine is unnecessarily coupled to three classes Selection, Recorder, and Location. This style of coding dramatically increases the number of classes on which our class depends. Why is this a bad thing? It increases the risk that an unrelated change somewhere else in the system will affect your code. For instance, if Fred makes a change to Location such that it no longer directly contains a TimeZone, you have to change your code as well.Rather than digging though a hierarchy yourself, just ask for what you need directly:                                             public void plotDate(Date aDate, TimeZone aTz) {       ...     }     plotDate(someDate, someSelection.getTimeZone());We added a method to Selection to get the time zone on our behalf: the plotting routine doesn't care whether the time zone comes from the Recorder directly, from some contained object within Recorder, or whether Selection makes up a different time zone entirely. The selection routine, in turn, should probably just ask the recorder for its time zone, leaving it up to the recorder to get it from its contained Location object.Traversing relationships between objects directly can quickly lead to a combinatorial explosion[1]  of dependency relationships. You can see symptoms of this phenomenon in anumber of ways: [1] If n objects all know about each other, then a change to just one object can result in the other n - 1objects needing changes.Large C or C++ projects where the command to link a unit test is longer than the 1. test program itself"Simple" changes to one module that propagate through unrelated modules in the system2.Developers who are afraid to change code because they aren't sure what might be affected3.Systems with many unnecessary dependencies are very hard (and expensive) to maintain, and tend to be highly unstable. In order to keep the dependencies to a minimum, we'll use the Law of Demeter to design our methods and functions.The Law of Demeter for FunctionsThe Law of Demeter for functions [LH89 ] attempts to minimize coupling between modules in any given program. It tries to prevent you from reaching into an object to gain access to a third object's methods. The law is summarized in Figure 5.1  on the next page. Figure 5.1. Law of Demeter for functions By writing "shy" code that honors the Law of Demeter as much as possible, we can achieve our objective: Tip 36Minimize Coupling Between ModulesDoes It Really Make a Difference?While it sounds good in theory, does following the Law of Demeter really help to create more maintainable code?Studies have shown [BBM96 ] that classes in C++ with larger response sets are more prone to error than classes with smaller response sets (a response set is defined to be the number of functions directly invoked by methods of the class).Because following the Law of Demeter reduces the size of the response set in the calling class, it follows that classes designed in this way will also tend to have fewer errors (see [URL 56 ] for more papers and information on the Demeter project).Using The Law of Demeter will make your code more adaptable and robust, but at a cost:as a "general contractor," your module must delegate and manage any and allsubcontractors directly, without involving clients of your module. In practice, this meansthat you will be writing a large number of wrapper methods that simply forward the requeston to a delegate. These wrapper methods will impose both a runtime cost and a spaceoverhead, which may be significanteven prohibitivein some applications.As with any technique, you must balance the pros and cons for your particular application. In database schema design it is common practice to "denormalize" the schema for a performance improvement: to violate the rules of normalization in exchange for speed. A similar tradeoff can be made here as well. In fact, by reversing the Law of Demeter and tightly coupling several modules, you may realize an important performance gain. As long as it is well known and acceptable for those modules to be coupled, your design is fine.Physical Decoupling In this section we're concerned largely with designing to keep things logically decoupled within systems. However, there is another kind of interdependence that becomes highly significant as systems grow larger.In his book Large-scale C++ software Design [Lak96 ], John Lakos addresses the issues surrounding the relationships among the files, directories, and libraries that make up a system. Large projects that ignore these physical design problems wind up withbuild cycles that are measured in days and unit tests that may drag in the entiresystem as support code, among other problems. Mr. Lakos argues convincinglythat logical and physical design must proceed in tandemthat undoing thedamage done to a large body of code by cyclic dependencies is extremelydifficult. We recommend this book if you are involved in large-scaledevelopments, even if C++ isn't your implementation language.Otherwise, you may find yourself on the road to a brittle, inflexible future. Or no future at all.Related sections include:Orthogonality Reversibility Design by Contract How to Balance Resources It's Just a View Pragmatic Teams Ruthless Testing ChallengesWe've discussed how using delegation makes it easier to obey the Law of Demeter and hence reduce coupling. However, writing all of the methods needed to forward calls to delegated classes is boring and error prone. What are the advantages and disadvantages of writing a preprocessor that generates these calls automatically? Should this preprocessor be run only once, or should it be used as part of the build?     private Vector myStuff;  public Colada() {    myBlender = new Blender();    myStuff = new Vector();  }  private void doSomething() {    myBlender.addIngredients(myStuff.elements());  }} 27.This example is in C++ .                                                                void processTransaction(BankAccount acct, int) {  Person *who;  Money amt;    amt.setValue(123.45);  acct.setBalance(amt);  who = acct.getOwner();  markWorkflow(who->name(), SET_BALANCE);}I l@ve RuBoard    I l@ve RuBoard   MetaprogrammingNo amount of genius can overcome a preoccupation with detailLevy's Eighth LawDetails mess up our pristine codeespecially if they change frequently. Every time wehave to go in and change the code to accommodate some change in business logic, or inthe law, or in management's personal tastes of the day, we run the risk of breaking thesystemof introducing a new bug.So we say "out with the details!" Get them out of the code. While we're at it, we can makeour code highly configurable and "soft"that is, easily adaptable to changes.Dynamic ConfigurationFirst, we want to make our systems highly configurable. Not just things such as screen colors and prompt text, but deeply ingrained items such as the choice of algorithms, database products, middleware technology, and user-interface style. These items should be implemented as configuration options, not through integration or engineering.Tip 37Configure, Don't IntegrateUse metadata to describe configuration options for an application: tuning parameters, user preferences, the installation directory, and so on.What exactly is metadata? Strictly speaking, metadata is data about data. The most common example is probably a database schema or data dictionary. A schema contains data that describes fields (columns) in terms of names, storage lengths, and other attributes. You should be able to access and manipulate this information just as you would any other data in the database. We use the term in its broadest sense. Metadata is any data that describes theapplicationhow it should run, what resources it should use, and so on. Typically,metadata is accessed and used at runtime, not at compile time. You use metadata all thetimeat least your programs do. Suppose you click on an option to hide the toolbar onyour Web browser. The browser will store that preference, as metadata, in some sort ofinternal database.This database might be in a proprietary format, or it might use a standard mechanism. Under Windows, either an initialization file (using the suffix .ini) or entries in the system Registry are typical. Under Unix, the X Window System provides similar functionality using Application Default files. Java uses Property files. In all of these environments, you specify a key to retrieve a value. Alternatively, more powerful and flexible implementations of metadata use an embedded scripting language (see Domain Languages , for details).The Netscape browser has actually implemented preferences using both of these techniques. In Version 3, preferences were saved as simple key/value pairs:                                             SHOW_TOOLBAR: FalseLater, Version 4 preferences looked more like JavaScript:                                             user_pref("custtoolbar.Browser.Navigation_Toolbar.open", false);Metadata-Driven ApplicationsBut we want to go beyond using metadata for simple preferences. We want to configure and drive the application via metadata as much as possible. Our goal is to think declaratively (specifying what is to be done, not how) and create highly dynamic andadaptable programs. We do this by adopting a general rule: program for the general case,and put the specifics somewhere elseoutside the compiled code base.Tip 38Put Abstractions in Code Details in Metadata There are several benefits to this approach:It forces you to decouple your design, which results in a more flexible and adaptable program. It forces you to create a more robust, abstract design by deferringdetailsdeferring them all the way out of the program. You can customize the application without recompiling it. You can also use this level of customization to provide easy work-arounds for critical bugs in live production systems. Metadata can be expressed in a manner that's much closer to the problem domain than a general-purpose programming language might be (see Domain Languages ). You may even be able to implement several different projects using the same application engine, but with different metadata. We want to defer definition of most details until the last moment, and leave the details assoftas easy to changeas we can. By crafting a solution that allows us to make changesquickly, we stand a better chance of coping with the flood of directional shifts that swampmany projects (see Reversibility ).Business LogicSo you've made the choice of database engine a configuration option, and provided metadata to determine the user-interface style. Can we do more? Definitely.Because business policy and rules are more likely to change than any other aspect of the project, it makes sense to maintain them in a very flexible format.For example, your purchasing application may include various corporate policies. Maybe you pay small suppliers in 45 days and large ones in 90 days. Make the definitions of the supplier types, as well as the time periods themselves, configurable. Take the opportunity to generalize.Maybe you are writing a system with horrendous workflow requirements. Actions start and stop according to complex (and changing) business rules. Consider encoding them in some kind of rule-based (or expert) system, embedded within your application. That way, you'll configure it by writing rules, not cutting code. Less complex logic can be expressed using a mini-language, removing the need to recompile and redeploy when the environment changes. Have a look at page 58 for an example.When to ConfigureAs mentioned in The power of plain Text , we recommend representingconfiguration metadata in plain textit makes life that much easier.But when should a program read this configuration? Many programs will scan such things only at startup, which is unfortunate. If you need to change the configuration, this forces you to restart the application. A more flexible approach is to write programs that can reload their configuration while they're running. This flexibility comes at a cost: it is more complex to implement.So consider how your application will be used: if it is a long-running server process, you will want to provide some way to reread and apply metadata while the program is running. For a small client GUI application that restarts quickly, you may not need to.This phenomenon is not limited to application code. We've all been annoyed at operating systems that force us to reboot when we install some simple application or change an innocuous parameter.An Example: Enterprise Java BeansEnterprise Java Beans (EJB) is a framework for simplifying programming in a distributed, transaction-based environment. We mention it here because EJB illustrates how metadata can be used both to configure applications and to reduce the complexity of writing code.Suppose you want to create some Java software that will participate in transactions across different machines, between different database vendors, and with different thread and load-balancing models.The good news is, you don't have to worry about all that. You write a beanaself-contained object that follows certain conventionsand place it in a bean containerthat manages much of the low-level detail on your behalf. You can write the code for a  bean without including any transaction operations or thread management; EJB uses metadata to specify how transactions should be handled.Thread allocation and load balancing are specified as metadata to the underlying transaction service that the container uses. This separation allows us great flexibility to configure the environment dynamically, at runtime.The bean's container can manage transactions on the bean's behalf in one of several different styles (including an option where you control your own commits and rollbacks). All of the parameters that affect the bean's behavior are specified in the bean's deploymentdescriptora serialized object that contains the metadata we need.Distributed systems such as EJB are leading the way into a new world of configurable, dynamic systems.Cooperative ConfigurationWe've talked about users and developers configuring dynamic applications. But whathappens if you let applications configure each othersoftware that adapts itself to itsenvironment? Unplanned, spur-of-the-moment configuration of existing software is apowerful concept.Operating systems already configure themselves to hardware as they boot, and Web browsers update themselves with new components automatically.Your larger applications probably already have issues with handling different versions of data and different releases of libraries and operating systems. Perhaps a more dynamic approach will help.Don't Write Dodo-CodeWithout metadata, your code is not as adaptable or flexible as it could be. Is this a bad thing? Well, out here in the real world, species that don't adapt die.The dodo didn't adapt to the presence of humans and their livestock on the island of Mauritius, and quickly became extinct.[2]  It was the first documented extinction of a speciesat the hand of man. [2] It didn't help that the settlers beat the placid (read stupid) birds to death with clubs for sport. Don't let your project (or your career) go the way of the dodo.Related sections include:Orthogonality Reversibility Domain Languages The Power of Plain Text ChallengesFor your current project, consider how much of the application might be moved out of the program itself to metadata. What would the resultant "engine" look like? Would you be able to reuse that engine in the context of a different application? Exercises 28.Which of the following things would be better represented as code within a  program, and which externally as metadata? Communication port assignments1.An editor's support for highlighting the syntax of various languages2.An editor's support for different graphic devices3.A state machine for a parser or scanner4.Sample values and results for use in unit testing5.I l@ve RuBoard    I l@ve RuBoard   Temporal CouplingWhat is temporal coupling all about, you may ask. It's about time.Time is an often ignored aspect of software architectures. The only time that preoccupies us is thetime on the schedule, the time left until we shipbut this is not what we're talking about here. Instead,we are talking about the role of time as a design element of the software itself. There are two aspectsof time that are important to us: concurrency (things happening at the same time) and ordering (therelative positions of things in time).We don't usually approach programming with either of these aspects in mind. When people first sitdown to design an architecture or write a program, things tend to be linear. That's the way most peoplethinkdo this and then always do that. But thinking this way leads to temporal coupling: coupling in time. Method A must always be called before method B; only one report can be run at a time; you must wait for the screen to redraw before the button click is received. Tick must happen before tock.This approach is not very flexible, and not very realistic.We need to allow for concurrency[3]  and to think about decoupling any time or order dependencies. Indoing so, we can gain flexibility and reduce any time-based dependencies in many areas of development: workflow analysis, architecture, design, and deployment. [3] We won't go into the details of concurrent or parallel programming here; a good computer sciencetextbook should cover the basics, including scheduling, deadlock, star-vation, mutual exclusion/semaphores, and so on.WorkflowOn many projects, we need to model and analyze the users' workflows as part of requirements analysis. We'd like to find out what can happen at the same time, and what must happen in a strict order. One way to do this is to capture their description of workflow using a notation such as the UML activity diagram.[4] [4] For more information on all of the UML diagram types, see [FS97 ].An activity diagram consists of a set of actions drawn as rounded boxes. The arrow leaving an action leads to either another action (which can start once the first action completes) or to a thick line called a synchronization bar. Once all the actions leading into a synchronization bar are complete, you can then proceed along any arrows leaving the bar. An action with no arrows leading into it can be started at any time.You can use activity diagrams to maximize parallelism by identifying activities that could be performed in parallel, but aren't.Tip 39 Analyze Workflow to Improve ConcurrencyFor instance, in our blender project (Exercise 17, page 119), users may initially describe their current workflow as follows.Open blender1.Open piña colada mix2.Put mix in blender3.Measure 1/2 cup white rum4.Pour in rum5.Add 2 cups of ice6.Close blender7.Liquefy for 2 minutes8.Open blender9.Get glasses10.Get pink umbrellas11.Serve12.Even though they describe these actions serially, and may even perform them serially, we notice that many of them could be performed in parallel, as we show in the activity diagram in Figure 5.2  on the next page. Figure 5.2. UML activity diagram: making a piña colada It can be eye-opening to see where the dependencies really exist. In this instance, the top-level tasks (1, 2, 4, 10, and 11) can all happen concurrently, up front. Tasks 3, 5, and 6 can happen in parallel later.If you were in a piña colada-making contest, these optimizations may make all the difference.ArchitectureWe wrote an On-Line Transaction Processing (OLTP) system a few years ago. At its simplest, all the system had to do was read a request and process the transaction against the database. But we wrote a three-tier, multiprocessing distributed application: each component was an independent entity that ran concurrently with all other components. While this sounds like more work, it wasn't: taking advantage of temporal decoupling made it easier to write. Let's take a closer look at this project.The system takes in requests from a large number of data communication lines and processes transactions against a back-end database.The design addresses the following constraints:Database operations take a relatively long time to complete.  For each transaction, we must not block communication services while a database transaction is being processed. Database performance suffers with too many concurrent sessions. Multiple transactions are in progress concurrently on each data line. The solution that gave us the best performance and cleanest architecture looked something like Figure  5.3 . Figure 5.3. OLTP architecture overview Each box represents a separate process; processes communicate via work queues. Each input process monitors one incoming communication line, and makes requests to the application server. All requests are asynchronous: as soon as the input process makes its current request, it goes back to monitoring the line for more traffic. Similarly, the application server makes requests of the database process,[5]  and is notified when the individual transaction is complete. [5] Even though we show the database as a single, monolithic entity, it is not. The database software ispartitioned into several processes and client threads, but this is handled internally by the database software and isn't part of our example.This example also shows a way to get quick and dirty load balancing among multiple consumer processes: the hungry consumer model.In a hungry consumer model, you replace the central scheduler with a number of independent consumer tasks and a centralized work queue. Each consumer task grabs a piece from the work queue and goes on about the business of processing it. As each task finishes its work, it goes back to the queue for some more. This way, if any particular task gets bogged down, the others can pick up the slack, and each individual component can proceed at its own pace. Each component is temporally decoupled from the others.Tip 40Design Using Services Instead of components, we have really created servicesindependent, concurrent objects behind well-defined, consistent interfaces.Design for ConcurrencyThe rising acceptance of Java as a platform has exposed more developers to multithreadedprogramming. But programming with threads imposes some design constraintsand that's a goodthing. Those constraints are actually so helpful that we want to abide by them whenever we program.It will help us decouple our code and fight programming by coincidence .With linear code, it's easy to make assumptions that lead to sloppy programming. But concurrencyforces you to think through things a bit more carefullyyou're not alone at the party anymore.Because things can now happen at the "same time," you may suddenly see some time-baseddependencies.To begin with, any global or static variables must be protected from concurrent access. Now may be a good time to ask yourself why you need a global variable in the first place. In addition, you need to make sure that you present consistent state information, regardless of the order of calls. For example, when is it valid to query the state of your object? If your object is in an invalid state between certain calls, you may be relying on a coincidence that no one can call your object at that point in time.Suppose you have a windowing subsystem where the widgets are first created and then shown on the display in two separate steps. You aren't allowed to set state in the widget until it is shown. Depending on how the code is set up, you may be relying on the fact that no other object can use the created widget until you've shown it on the screen.But this may not be true in a concurrent system. Objects must always be in a valid state when called, and they can be called at the most awkward times. You must ensure that an object is in a valid state any time it could possibly be called. Often this problem shows up with classes that define separate constructor and initialization routines (where the constructor doesn't leave the object in an initialized state). Using class invariants, discussed in Design by Contract , will help you avoid this trap.Cleaner InterfacesThinking about concurrency and time-ordered dependencies can lead you to design cleaner interfaces as well. Consider the C library routine strtok, which breaks a string into tokens.The design of strtok isn't thread safe,[6]  but that isn't the worst part: look at the time dependency. Youmust make the first call to strtok with the variable you want to parse, and all successive calls with a NULL instead. If you pass in a non-NULL value, it restarts the parse on that buffer instead. Without even considering threads, suppose you wanted to use strtok to parse two separate strings at the same time: [6] It uses static data to maintain the current position in the buffer. The static data isn't protected against  Once you've designed an architecture with an element of concurrency, it becomes easier to think about handling many concurrent services: the model becomes pervasive.Now you can be flexible as to how the application is deployed: standalone, client-server, or n-tier. Byarchitecting your system as independent services, you can make the configuration dynamic as well. Byplanning for concurrency, and decoupling operations in time, you have all these optionsincluding thestand-alone option, where you can choose not to be concurrent.Going the other way (trying to add concurrency to a nonconcurrent application) is much harder. If wedesign to allow for concurrency, we can more easily meet scalability or performance requirementswhen the time comesand if the time never comes, we still have the benefit of a cleaner design.Isn't it about time?Related sections include:Design by Contract Programming by Coincidence ChallengesHow many tasks do you perform in parallel when you get ready for work in the morning? Could you express this in a UML activity diagram? Can you find some way to get ready more quickly by increasing concurrency? I l@ve RuBoard     usually dominated by a huge case statement or multiway if-then. We can do better.Objects should be able to register to receive only the events they need, and should never be sent events they don't need. We don't want to spam our objects! Instead, we can use a publish/subscribeprotocol, illustrated using the UML sequence diagram in Figure 5.4  on the next page.[7] [7] See also the Observer pattern in [GHJV95 ] for more information. Figure 5.4. Publish/subscribe protocol A sequence diagram shows the flow of messages among several objects, with objects arranged in columns. Each message is shown as a labeled arrow from the sender's column to the receiver's column. An asterisk in the label means that more than one message of this type can be sent.If we are interested in certain events generated by a Publisher, all we have to do is register ourselves. The Publisher keeps track of all interested Subscriber objects; when the Publisher generates an event of interest, it will call each Subscriber in turn and notify them that the event has occurred.There are several variations on this thememirroring other communication styles. Objects may usepublish/subscribe on a peer-to-peer basis (as we saw above); they may use a "software bus" where acentralized object maintains the database of listeners and dispatches messages appropriately. Youmight even have a scheme where critical events get broadcast to all listenersregistered or not. Onepossible implementation of events in a distributed environment is illustrated by the CORBA EventService, described in the box on the following page.We can use this publish/subscribe mechanism to implement a very important design concept: the separation of a model from views of the model. Let's start with a GUI-based example, using the  Smalltalk design in which this concept was born.Model-View-ControllerSuppose you have a spreadsheet application. In addition to the numbers in the spreadsheet itself, you also have a graph that displays the numbers as a bar chart and a running total dialog box that shows the sum of a column in the spreadsheet.The CORBA Event ServiceThe CORBA Event Service allows participating objects to send and receive event notifications via a common bus, the event channel. The event channel arbitrates event handling, and also decouples event producers from event consumers. It works in two basic ways: push and pull.In push mode, event suppliers inform the event channel that an event has occurred. The channel then automatically distributes that event to all client objects that have registered interest.In pull mode, clients periodically poll the event channel, which in turn polls the supplier that offers event data corresponding to the request.Although the CORBA Event Service can be used to implement all of the event models discussed in this section, you can also view it as a different animal. CORBA facilities communication among objects written in different programming languages running on geographically dispersed machines with different architectures. Sitting on top of CORBA, the event service give you a decoupled way of interacting with applications around the world, written by people you've never met, using programming languages you'd rather not know about.Obviously, we don't want to have three separate copies of the data. So we create a modelthe data itself, with common operations to manipulate it. Then we can create separate views that display the data in different ways: as a spreadsheet, as a graph, or in a totals box. Each of these views may have its own controller. The graph view may have a controller that allows you to zoom in or out, or pan around the data, for example. None of this affects the data itself, just that view.This is the key concept behind the Model-View-Controller (MVC0 idiom: separating the model from both the GUI that represents it and the controls that manage the view.[8]   [8] The view and controller are tightly coupled, and in some Implementations of MVC the view andcontroller are a single component.By doing so, you can take advantage of some interesting possibilities. You can support multiple views of the same data model. You can use common viewers on many different data models. You can even support multiple controllers to provide nontraditional input mechanisms.Tip 42Separate Views from ModelsBy loosening the coupling between the model and the view/controller, you buy yourself a lot of flexibility at low cost. In fact, this technique is one of the most important ways of maintaining reversibility (see Reversibility ).Java Tree ViewA good example of an MVC design can be found in the Java tree widget. The tree widget (which displays a clickable, traversable tree) is actually a set of several different classes organized in an MVC pattern.To produce a fully functional tree widget, all you need to do is provide a data source that conforms to the TreeModel interface. Your code now becomes the model for the tree.The view is created by the TreeCellRenderer and TreeCellEditor classes, which can be inherited from and customized to provide different colors, fonts, and icons in the widget. JTree acts as the controller for the tree widget and provides some general viewing functionality.Because we have decoupled the model from the view, we simplify the programming a great deal. You don't have to think about programming a tree widget anymore. Instead, you just provide a data source.Suppose the vice president comes up to you and wants a quick application that lets her navigate the company's organizational chart, which is held in a legacy database on the mainframe. Just write a wrapper that takes the mainframe data, presents it as a TreeModel, and voilà: you have a fully navigable tree widget.Now you can get fancy and start using the viewer classes; you can change how nodes are rendered, and use special icons, fonts, or colors. When the VP comes back and says the new corporate standards dictate the use of a Skull and Crossbones icon for certain employees, you can make the changes to TreeCellRenderer without touching any other code.   Figure 5.5. Baseball reporting, Viewers subscribe to models. This kind of model-viewer network is a common (and valuable) design technique. Each link decouplesraw data from the events that created iteach new viewer is an abstraction. And because therelationships are a network (not just a linear chain), we have a lot of flexibility. Each model may havemany viewers, and one viewer may work with multiple models.In advanced systems such as this one, it can be handy to have debugging viewsspecialized views that show you in-depth details of the model. Adding a facility to trace individual events can be a great time saver as well.Still Coupled (After All These Years)Despite the decrease in coupling we have achieved, listeners and event generators (subscribers and publishers) still have some knowledge of each other. In Java, for instance, they must agree on common interface definitions and calling conventions.In the next section, we'll look at ways of reducing coupling even further by using a form of publish and subscribe where none of the participants need know about each other, or call each other directly.Related sections include:Orthogonality  Reversibility Decoupling and the Law of Demeter Blackboards It's All Writing Exercises 29.Suppose you have an airline reservation system that includes the concept of a flight :                                                                     public interface Flight {       // Return false if flight full.       public boolean addPassenger(Passenger p);       public void addToWaitList(Passenger p);       public int getFlightCapacity();       public int getNumPassengers();     }If you add a passenger to the wait list, they'll be put on the flight automatically when an opening becomes available.There's a massive reporting job that goes through looking for overbooked or full flights to suggest when additional flights might be scheduled. It works fine, but it takes hours to run.We'd like to have a little more flexibility in processing wait-list passengers, and we've gotto do something about that big reportit takes too long to run. Use the ideas from thissection to redesign this interface.I l@ve RuBoard    I l@ve RuBoard   BlackboardsThe writing is on the wallYou may not usually associate elegance with police detectives, picturing instead some sort of doughnut and coffee cliché. But consider how detectives might use a blackboard to coordinate and solve a murder investigation.Suppose the chief inspector starts off by setting up a large blackboard in the conference room. On it, he writes a single question:H. DUMPTY (MALE, EGG): ACCIDENT OR MURDER?Did Humpty really fall, or was he pushed? Each detective may make contributions to this potential murder mystery by adding facts, statements from witnesses, any forensic evidence that might arise, and so on. As the data accumulates, a detective might notice a connection and post that observation or speculation as well. This process continues, across all shifts, with many different people and agents, until the case is closed. A sample blackboard is shown in Figure 5.6  on the next page. Figure 5.6. Someone found a connection between Humpty's gambling debts and the phone logs. Perhaps he was getting threatening phone calls. Some key features of the blackboard approach are:None of the detectives needs to know of the existence of any other detectivethey watch theboard for new information, and add their findings. The detectives may be trained in different disciplines, may have different levels of education and expertise, and may not even work in the same precinct. They share a desire to solve the case, but that's all. Different detectives may come and go during the course of the process, and may work different shifts.  There are no restrictions on what may be placed on the blackboard. It may be pictures, sentences, physical evidence, and so on. We've worked on a number of projects that involved a workflow or distributed data gathering process. With each, designing a solution around a simple blackboard model gave us a solid metaphor to work with: all of the features listed above using detectives are just as applicable to objects and code modules.A blackboard system lets us decouple our objects from each other completely, providing a forum where knowledge consumers and producers can exchange data anonymously and asynchronously. As you might guess, it also cuts down on the amount of code we have to write.Blackboard ImplementationsComputer-based blackboard systems were originally invented for use in artificial intelligenceapplications where the problems to be solved were large and complexspeech recognition,knowledge-based reasoning systems, and so on.Modern distributed blackboard-like systems such as JavaSpaces and T Spaces [URL 50 , URL 25 ] are based on a model of key/value pairs first popularized in Linda [CG90 ], where the concept was known as tuple space.With these systems, you can store active Java objectsnot just dataon the blackboard, and retrievethem by partial matching of fields (via templates and wildcards) or by subtypes. For example, supposeyou had a type Author, which is a subtype of Person. You could search a blackboard containing Person objects by using an Author template with a lastName value of "Shakespeare." You'd get Bill Shakespeare the author, but not Fred Shakespeare the gardener.The main operations in JavaSpaces are:NameFunctionreadSearch for and retrieve data from the space.writePut an item into the space.takeSimilar to read, but removes the item from the space as well.notifySet up a notification to occur whenever an object is written that matches the template.T Spaces supports a similar set of operations, but with different names and slightly different semantics. Both systems are built like a database product; they provide atomic operations and distributed transactions to ensure data integrity.Since we can store objects, we can use a blackboard to design algorithms based on a flow of objects,not just data. It's as if our detectives could pin people to the blackboardwitnesses themselves, notjust their statements. Anyone can ask a witness questions in the pursuit of the case, post thetranscript, and move that witness to another area of the blackboard, where he might responddifferently (if you allow the witness to read the blackboard too). A big advantage of systems such as these is that you have a single, consistent interface to the blackboard. When building a conventional distributed application, you can spend a great deal of time crafting unique API calls for every distributed transaction and interaction in the system. With the combinatorial explosion of interfaces and interactions, the project can quickly become a nightmare.Organizing Your BlackboardWhen the detectives work on large cases, the blackboard may be- come cluttered, and it may become difficult to locate data on the board. The solution is to partition the blackboard and start to organize the data on the blackboard somehow.Different software systems handle this partitioning in different ways; some use fairly flat zones or interests groups, while others adopt a more hierarchical treelike structure.The blackboard style of programming removes the need for so many interfaces, making for a more elegant and consistent system.Application ExampleSuppose we are writing a program to accept and process mortgage or loan applications. The laws thatgovern this area are odiously complex, with federal, state, and local governments all having their say.The lender must prove they have disclosed certain things, and must ask for certain informationbutmust not ask certain other questions, and so on, and so on.Beyond the miasma of applicable law, we also have the following problems to contend with.There is no guarantee on the order in which data arrives. For instance, queries for a credit check or title search may take a substantial amount of time, while items such as name and address may be available immediately. Data gathering may be done by different people, distributed across different offices, in different time zones. Some data gathering may be done automatically by other systems. This data may arrive asynchronously as well. Nonetheless, certain data may still be dependent on other data. For instance, you may not be able to start the title search for a car until you get proof of ownership or insurance. Arrival of new data may raise new questions and policies. Suppose the credit check comes back with a less than glowing report; now you need these five extra forms and perhaps a   blood sample.You can try to handle every possible combination and circumstance using a workflow system. Many such systems exist, but they can be complex and programmer intensive. As regulations change, the work-flow must be reorganized: people may have to change their procedures and hard-wired code may have to be rewritten.A blackboard, in combination with a rules engine that encapsulates the legal requirements, is an elegant solution to the difficulties found here. Order of data arrival is irrelevant: when a fact is posted it can trigger the appropriate rules. Feedback is easily handled as well: the output of any set of rules can post to the blackboard and cause the triggering of yet more applicable rules.Tip 43Use Blackboards to Coordinate WorkflowWe can use the blackboard to coordinate disparate facts and agents, while still maintaining independence and even isolation among participants.You can accomplish the same results with more brute-force methods, of course, but you'll have a more brittle system. When it breaks, all the king's horses and all the king's men might not get your program working again.Related sections include:The Power of Plain Text It's Just a View ChallengesDo you use blackboard systems in the real worldthe message board by the refrigerator, orthe big whiteboard at work? What makes them effective? Are messages ever posted with aconsistent format? Does it matter? Exercises30.For each of the following applications, would a blackboard system be appropriate or not?  Why? Image processing.   You'd like to have a number of parallel processes grab1. chunks of an image, process them, and put the completed chunk back.Group calendaring.   You've got people scattered across the globe, in differenttime zones, and speaking different languages, trying to schedule a meeting.2.Network monitoring tool.   The system gathers performance statistics andcollects trouble reports. You'd like to implement some agents to use this information to look for trouble in the system.3.I l@ve RuBoard    I l@ve RuBoard   Chapter 6. While You Are CodingConventional wisdom says that once a project is in the coding phase, the work is mostly mechanical, transcribing the design into executable statements. We think that this attitude is the single biggest reason that many programs are ugly, inefficient, poorly structured, unmaintainable, and just plain wrong.Coding is not mechanical. If it were, all the CASE tools that people pinned their hopes on in the early1980s would have replaced programmers long ago. There are decisions to be made everyminutedecisions that require careful thought and judgment if the resulting program is to enjoy a long,accurate, and productive life.Developers who don't actively think about their code are programming by coincidencethe codemight work, but there's no particular reason why. In Programming by Coincidence, we advocate a more positive involvement with the coding process.While most of the code we write executes quickly, we occasionally develop algorithms that have the potential to bog down even the fastest processors. In Algorithm Speed, we discuss ways to estimate the speed of code, and we give some tips on how to spot potential problems before they happen.Pragmatic Programmers think critically about all code, including our own. We constantly see room for improvement in our programs and our designs. In Refactoring, we look at techniques that help us fix up existing code even while we're in the midst of a project.Something that should be in the back of your mind whenever you're producing code is that you'll someday have to test it. Make code easy to test, and you'll increase the likelihood that it will actually get tested, a thought we develop in Code That's Easy to Test.Finally, in Evil Wizards, we suggest that you should be careful of tools that write reams of code on your behalf unless you understand what they're doing.Most of us can drive a car largely on autopilotwe don't explicitly command our foot to press a pedal,or our arm to turn the wheelwe just think "slow down and turn right." However, good, safe drivers areconstantly reviewing the situation, checking for potential problems, and putting themselves into goodpositions in case the unexpected happens. The same is true of codingit may be largely routine, butkeeping your wits about you could well prevent a disaster.I l@ve RuBoard    I l@ve RuBoard   Programming by CoincidenceDo you ever watch old black-and-white war movies? The weary soldier advances cautiously out of thebrush. There's a clearing ahead: are there any land mines, or is it safe to cross? There aren't anyindications that it's a minefieldno signs, barbed wire, or craters. The soldier pokes the ground aheadof him with his bayonet and winces, expecting an explosion. There isn't one. So he proceedspainstakingly through the field for a while, prodding and poking as he goes. Eventually, convinced thatthe field is safe, he straightens up and marches proudly forward, only to be blown to pieces.The soldier's initial probes for mines revealed nothing, but this was merely lucky. He was led to a falseconclusionwith disastrous results.As developers, we also work in minefields. There are hundreds of traps just waiting to catch us eachday. Remembering the soldier's tale, we should be wary of drawing false conclusions. We shouldavoid programming by coincidencerelying on luck and accidental successes in favor ofprogramming deliberately.How to Program by CoincidenceSuppose Fred is given a programming assignment. Fred types in some code, tries it, and it seems to work. Fred types in some more code, tries it, and it still seems to work. After several weeks of coding this way, the program suddenly stops working, and after hours of trying to fix it, he still doesn't know why. Fred may well spend a significant amount of time chasing this piece of code around without ever being able to fix it. No matter what he does, it just doesn't ever seem to work right.Fred doesn't know why the code is failing because he didn't know why it worked in the first place. It seemed to work, given the limited "testing" that Fred did, but that was just a coincidence. Buoyed by false confidence, Fred charged ahead into oblivion. Now, most intelligent people may know someone like Fred, but we know better. We don't rely on coincidencesdo we?Sometimes we might. Sometimes it can be pretty easy to confuse a happy coincidence with a purposeful plan. Let's look at a few examples.Accidents of ImplementationAccidents of implementation are things that happen simply because that's the way the code is currently written. You end up relying on undocumented error or boundary conditions.Suppose you call a routine with bad data. The routine responds in a particular way, and you codebased on that response. But the author didn't intend for the routine to work that wayit was nevereven considered. When the routine gets "fixed," your code may break. In the most extreme case, theroutine you called may not even be designed to do what you want, but it seems to work okay. Calling things in the wrong order, or in the wrong context, is a related problem.                                                  documented and are often in conflict between different developers. Assumptions that aren't based onwell-established facts are the bane of all projects.Tip 44Don't Program by CoincidenceHow to Program DeliberatelyWe want to spend less time churning out code, catch and fix errors as early in the development cycle as possible, and create fewer errors to begin with. It helps if we can program deliberately:Always be aware of what you are doing. Fred let things get slowly out of hand, until he ended up boiled, like the frog in Stone Soup and Boiled Frogs . Don't code blindfolded. Attempting to build an application you don't fully understand, or to use a technology you aren't familiar with, is an invitation to be misled by coincidences. Proceed from a plan, whether that plan is in your head, on the back of a cocktail napkin, or on a wall-sized printout from a CASE tool. Rely only on reliable things. Don't depend on accidents or assumptions. If you can't tell the difference in particular circumstances, assume the worst. Document your assumptions. Design by Contract , can help clarify your assumptions in your own mind, as well as help communicate them to others. Don't just test your code, but test your assumptions as well. Don't guess; actually try it. Write an assertion to test your assumptions (see Assertive Programming ). If your assertion is right, you have improved the documentation in your code. If you discover your assumption is wrong, then count yourself lucky. Prioritize your effort. Spend time on the important aspects; more than likely, these are the hard parts. If you don't have fundamentals or infrastructure correct, brilliant bells and whistles will be irrelevant. Don't be a slave to history. Don't let existing code dictate future code. All code can bereplaced if it is no longer appropriate. Even within one program, don't let what you've alreadydone constrain what you do nextbe ready to refactor (see Refactoring ). This decision may impact the project schedule. The assumption is that the impact will be less than the cost of not making the change.[1] [1] You can also go too far here. We once knew a developer who rewrote all source he wasgiven because he had his own naming conventions.    I l@ve RuBoard   Algorithm SpeedIn Estimating, we talked about estimating things such as how long it takes to walk across town, or howlong a project will take to finish. However, there is another kind of estimating that PragmaticProgrammers use almost daily: estimating the resources that algorithms usetime, processor,memory, and so on.This kind of estimating is often crucial. Given a choice between two ways of doing something, which do you pick? You know how long your program runs with 1,000 records, but how will it scale to 1,000,000? What parts of the code need optimizing?It turns out that these questions can often be answered using common sense, some analysis, and a way of writing approximations called the "big O" notation.What Do We Mean by Estimating Algorithms?Most nontrivial algorithms handle some kind of variable inputsorting n strings, inverting an m × nmatrix, or decrypting a message with an n-bit key. Normally, the size of this input will affect the algorithm: the larger the input, the longer the running time or the more memory used.If the relationship were always linear (so that the time increased in direct proportion to the value of n), this section wouldn't be important. However, most significant algorithms are not linear. The good news is that many are sublinear. A binary search, for example, doesn't need to look at every candidate when finding a match. The bad news is that other algorithms are considerably worse than linear; runtimes or memory requirements increase far faster than n. An algorithm that takes a minute to process ten items may take a lifetime to process 100.We find that whenever we write anything containing loops or recursive calls, we subconsciously check the runtime and memory requirements. This is rarely a formal process, but rather a quick confirmation that what we're doing is sensible in the circumstances. However, we sometimes do find ourselves performing a more detailed analysis. That's when the O() notation comes in useful.The O() NotationThe O() notation is a mathematical way of dealing with approximations. When we write that a particular sort routine sorts n records in O(n2) time, we are simply saying that the worst-case time taken will vary as the square of n. Double the number of records, and the time will increase roughly fourfold. Think of the O as meaning on the order of. The O() notation puts an upper bound on the value of the thing we're measuring (time, memory, and so on). If we say a function takes O(n2) time, then weknow that the upper bound of the time it takes will not grow faster than n2. Sometimes we come up with fairly complex O() functions, but because the highest-order term will dominate the value as nincreases, the convention is to remove all low-order terms, and not to bother showing any constant multiplying factors. O(n2/2+ 3n) is the same as O(n2/2), which is equivalent to O(n2). This is actually a  weakness of the O() notationone O(n2) algorithm may be 1,000 times faster than another O(n2) algorithm, but you won't know it from the notation.Figure 6.1  shows several common O() notations you'll come across, along with a graph comparing running times of algorithms in each category. Clearly, things quickly start getting out of hand once we get overO(n2). Figure 6.1. Runtimes of various algorithms For example, suppose you've got a routine that takes 1 s to process 100 records. How long will it take to process 1,000? If your code is O(1), then it will still take 1 s. If it's O(lg(n)), then you'll probably be waiting about 3 s. O(n) will show a linear increase to 10 s, while an O(n lg(n)) will take some 33 s. If you're unlucky enough to have an O(n2) routine, then sit back for 100 s while it does its stuff. And if you're using an exponential algorithm O(2n), you might want to make a cup of coffeeyour routine should finish in about 10263 years. Let us know how the universe ends.The O() notation doesn't apply just to time; you can use it to represent any other resources used by an algorithm. For example, it is often useful to be able to model memory consumption (see Exercise 35).Common Sense EstimationYou can estimate the order of many basic algorithms using common sense.Simple loops.   If a simple loop runs from 1 to n, then the algorithm is likely to be O(n)time increases linearly with n. Examples include exhaustive searches, finding the maximum value in an array, and generating checksums. Nested loops.   If you nest a loop inside another, then your algorithm becomes O(m × n),where m and n are the two loops' limits. This commonly occurs in simple sorting algorithms, such as bubble sort, where the outer loop scans each element in the array in turn, and the inner loop works out where to place that element in the sorted result. Such sorting algorithms tend to be O(n2). Binary chop.   If your algorithm halves the set of things it considers each time around theloop, then it is likely to be logarithmic, O(lg(n)) (see Exercise 37). A binary search of a sorted list, traversing a binary tree, and finding the first set bit in a machine word can all be O(lg(n)). Divide and conquer.   Algorithms that partition their input, work on the two halvesindependently, and then combine the result can be O(n lg(n)). The classic example is quicksort, which works by partitioning the data into two halves and recursively sorting each. Although technically O(n2), because its behavior degrades when it is fed sorted input, the average runtime of quicksort is O(n lg(n)). Combinatoric.   Whenever algorithms start looking at the permutations of things, theirrunning times may get out of hand. This is because permutations involve factorials (there are 5! = 5 × 4 × 3 × 2 × 1 = 120 permutations of the digits from 1 to 5). Time a combinatoricalgorithm for five elements: it will take six times longer to run it for six, and 42 times longer for seven. Examples include algorithms for many of the acknowledged hard problemsthetraveling salesman problem, optimally packing things into a container, partitioning a set ofnumbers so that each set has the same total, and so on. Often, heuristics are used to reducethe running times of these types of algorithms in particular problem domains. Algorithm Speed in PracticeIt's unlikely that you'll spend much time during your career writing sort routines. The ones in the libraries available to you will probably outperform anything you may write without substantial effort. However, the basic kinds of algorithms we've described earlier pop up time and time again. Wheneveryou find yourself writing a simple loop, you know that you have an O(n) algorithm. If that loop contains an inner loop, then you're looking at O(m × n). You should be asking yourself how large these values can get. If the numbers are bounded, then you'll know how long the code will take to run. If the  numbers depend on external factors (such as the number of records in an overnight batch run, or the number of names in a list of people), then you might want to stop and consider the effect that large values may have on your running time or memory consumption.Tip 45Estimate the Order of Your AlgorithmsThere are some approaches you can take to address potential problems. If you have an algorithm that is O(n2), try to find a divide and conquer approach that will take you down to O(n lg(n)).If you're not sure how long your code will take, or how much memory it will use, try running it, varying the input record count or whatever is likely to impact the runtime. Then plot the results. You should soon get a good idea of the shape of the curve. Is it curving upward, a straight line, or flattening off as the input size increases? Three or four points should give you an idea.Also consider just what you're doing in the code itself. A simple O(n2) loop may well perform better that a complex, O(n lg(n)) one for smaller values of n, particularly if the O(n lg(n)) algorithm has an expensive inner loop.In the middle of all this theory, don't forget that there are practical considerations as well. Runtime may look like it increases linearly for small input sets. But feed the code millions of records and suddenlythe time degrades as the system starts to thrash. If you test a sort routine with random input keys, you may be surprised the first time it encounters ordered input. Pragmatic Programmers try to cover both the theoretical and practical bases. After all this estimating, the only timing that counts is the speed of your code, running in the production environment, with real data.[2]  This leads to our next tip. [2] In fact, while testing the sort algorithms used as an exercise for this section on a 64MB Pentium, theauthors ran out of real memory while running the radix sort with more than seven million numbers. The sort started using swap space, and times degraded dramatically.Tip 46Test Your EstimatesIf it's tricky getting accurate timings, use code profilers to count the number of times the different steps in your algorithm get executed, and plot these figures against the size of the input.Best Isn't Always Best You also need to be pragmatic about choosing appropriate algorithmsthe fastest one is not alwaysthe best for the job. Given a small input set, a straightforward insertion sort will perform just as well asa quicksort, and will take you less time to write and debug. You also need to be careful if the algorithmyou choose has a high setup cost. For small input sets, this setup may dwarf the running time andmake the algorithm inappropriate.Also be wary of premature optimization. It's always a good idea to make sure an algorithm really is a bottleneck before investing your precious time trying to improve it.Related sections include:Estimating ChallengesEvery developer should have a feel for how algorithms are designed and analyzed. Robert Sedgewick has written a series of accessible books on the subject ([Sed83 , SF96 , Sed92 ] and others). We recommend adding one of his books to your collection, and making a point of reading it. For those who like more detail than Sedgewick provides, read Donald Knuth's definitive Art of Computer Programming books, which analyze a wide range of algorithms [Knu97a , Knu97b , Knu98 ]. In Exercise 34, we look at sorting arrays of long integers. What is the impact if the keys are more complex, and the overhead of key comparison is high? Does the key structure affect the efficiency of the sort algorithms, or is the fastest sort always fastest? Exercises 34.We have coded a set of simple sort routines, which can be downloaded from our Web  site ( http://www.pragmaticprogrammer.com ). Run them on various machines available to you. Do your figures follow the expected curves? What can you deduce about the relative speeds of your machines? What are the effects of various compiler optimization settings? Is the radix sort indeed linear? 35.The routine below prints out the contents of a binary tree. Assuming the tree is  balanced, roughly how much stack space will the routine use while printing a tree of  1,000,000 elements? (Assume that subroutine calls impose no significant stack  overhead.)                                                                     void printTree(const Node *node) {     char buffer[1000];     if (node) {        printTree(node->left);        getNodeAsString(node, buffer);        puts(buffer);        printTree(node->right);      }    } 36.Can you see any way to reduce the stack requirements of the routine in Exercise 35  (apart from reducing the size of the buffer)? 37.we claimed that a binary chop is  O (lg(n)). Can you prove this? I l@ve RuBoard      Keep track of the things that need to be refactored. If you can't refactor something immediately, make sure that it gets placed on the schedule. Make sure that users of the affected code know that it is scheduled to be refactored and how this might affect them.How Do You Refactor?Refactoring started out in the Smalltalk community, and, along with other trends (such as design patterns), has started to gain a wider audience. But as a topic it is still fairly new; there isn't much published on it. The first major book on refactoring ([FBB + 99 ], and also [URL 47 ]) is being published around the same time as this book.At its heart, refactoring is redesign. Anything that you or others on your team designed can be redesigned in light of new facts, deeper understandings, changing requirements, and so on. But if you proceed to rip up vast quantities of code with wild abandon, you may find yourself in a worse position than when you started.Clearly, refactoring is an activity that needs to be undertaken slowly, deliberately, and carefully. Martin Fowler offers the following simple tips on how to refactor without doing more harm than good (see the box on in [FS97 ]):Don't try to refactor and add functionality at the same time.1.Make sure you have good tests before you begin refactoring. Run the tests as often as possible. That way you will know quickly if your changes have broken anything.Automatic RefactoringHistorically, Smalltalk users have always enjoyed a class browser as part of the IDE. Not to be confused with Web browsers, class browsers let users navigate through and examine class hierarchies and methods.Typically, class browsers allow you to edit code, create new methods and classes, and so on. The next variation on this idea is the refactoring browser.A refactoring browser can semiautomatically perform common refactoring operations for you: splitting up a long routine into smaller ones, automatically propagating changes to method and variable names, drag and drop to assist you in moving code, and so on.2. As we write this book, this technology has yet to appear outside of theSmalltalk world, but this is likely to change at the same speed that Javachangesrapidly. In the meantime, the pioneering Small-talk refactoringbrowser can be found online at [URL 20 ].Take short, deliberate steps: move a field from one class to another, fuse two similar methods into a superclass. Refactoring often involves making many localized changes that result in a larger-scale change. If you keep your steps small, and test after each step, you will avoid prolonged debugging.3.We'll talk more about testing at this level in Code That's Easy to Test , and larger-scale testing in Ruthless Testing , but Mr. Fowler's point of maintaining good regression tests is the key to refactoring with confidence.It can also be helpful to make sure that drastic changes to a modulesuch as altering its interface orits functionality in an incompatible mannerbreak the build. That is, old clients of this code should fallto compile. You can then quickly find the old clients and make the necessary changes to bring them upto date.So next time you see a piece of code that isn't quite as it should be, fix both it and everything that depends on it. Manage the pain: if it hurts now, but is going to hurt even more later, you might as well get it over with. Remember the lessons of Software Entropy , don't live with broken windows.Related sections include:The Cat Ate My Source Code Software Entropy Stone Soup and Boiled Frogs The Evils of Duplication Orthogonality Programming by Coincidence Code That's Easy to Test Ruthless Testing Exercises  38.The following code has obviously been updated several times over the years, but the  changes haven't improved its structure. Refactor it .                                                                    if (state == TEXAS) {      rate = TX_RATE;      amt  = base * TX_RATE;      calc = 2*basis(amt) + extra(amt)*1.05;    }    else if ((state == OHIO) || (state == MAINE;      rate = (state == OHIO) ? OH_RATE : MN_RATE]      amt  = base * rate;      calc = 2*basis(amt) + extra(amt)*1.05;      if (state == OHIO)        points = 2;    }    else {      rate = 1;      amt  = base;      calc = 2*basis(amt) + extra(amt)*1.05;    } 39.The following Java class needs to support a few more shapes. Refactor the class to  prepare it for the additions .                                                                   public class Shape {     public static final int SQUARE   = 1;     public static final int CIRCLE   = 2;     public static final int RIGHT_TRIANGLE = 3;     private int shapeType;     private double size;     public Shape(int shapeType, double size) {       this.shapeType = shapeType;       this.size = size;     }     // ... other methods ...     public double area(){       switch (shapeType) {        case SQUARE:   return size*size;       case CIRCLE:   return Math.PI*size*size/4.0;       case RIGHT_TRIANGLE: return size*size/2.0;       }       return 0;      }    } 40.This Java code is part of a framework that will be used throughout your project. Refactor  it to be more general and easier to extend in the future .                                                                    public class Window {      public Window(int width, int height) { ... }      public void setSize(int width, int height) { ... }      public boolean overlaps(Window w) { ... }      public int getArea() { ... }    }                                                                I l@ve RuBoard    I l@ve RuBoard   Code That's Easy to TestThe Software IC is a metaphor that people like to toss around when discussing reusability and component-based development.[3]  The idea is that software components should be combined just asintegrated circuit chips are combined. This works only if the components you are using are known to be reliable. [3] The term "Software IC" (Integrated Circuit) seems to have been invented in 1986 by Cox andNovobilski in their Objective-C book Object-Oriented Programming [CN91 ].Chips are designed to be testednot just at the factory, not just when they are installed, but also inthe field when they are deployed. More complex chips and systems may have a full Built-in Self Test(BIST) feature that runs some base-level diagnostics internally, or a Test Access Mechanism (TAM)that provides a test harness that allows the external environment to provide stimuli and collectresponses from the chip.We can do the same thing in software. Like our hardware colleagues, we need to build testability into the software from the very beginning, and test each piece thoroughly before trying to wire them together.Unit TestingChip-level testing for hardware is roughly equivalent to unit testing in softwaretesting done on eachmodule, in isolation, to verify its behavior. We can get a better feeling for how a module will react in thebig wide world once we have tested it throughly under controlled (even contrived) conditions.A software unit test is code that exercises a module. Typically, the unit test will establish some kind of artificial environment, then invoke routines in the module being tested. It then checks the results that are returned, either against known values or against the results from previous runs of the same test (regression testing).Later, when we assemble our "software IC's" into a complete system, we'll have confidence that the individual parts work as expected, and then we can use the same unit test facilities to test the system as a whole. We talk about this large-scale checking of the system in Ruthless Testing .Before we get that far, however, we need to decide what to test at the unit level. Typically, programmers throw a few random bits of data at the code and call it tested. We can do much better, using the ideas behind design by contract.Testing Against Contract We like to think of unit testing as testing against contract (see Design by Contract ). We want to write test cases that ensure that a given unit honors its contract. This will tell us two things: whether the code meet the contract, and whether the contract means what we think it means. We want to test that the module delivers the functionality it promises, over a wide range of test cases and boundary conditions.What does this mean in practice? Let's look at the square root routine we first encountered on page 114. Its contract is simple:                                            require:      argument >= 0;    ensure:      ((result * result) - argument).abs <= epsilon*argument;This tells us what to test:Pass in a negative argument and ensure that it is rejected. Pass in an argument of zero to ensure that it is accepted (this is the boundary value). Pass in values between zero and the maximum expressible argument and verify that the difference between the square of the result and the original argument is less than some small fraction of the argument. Armed with this contract, and assuming that our routine does its own pre- and postcondition checking, we can write a basic test script to exercise the square root function.                                            public void testValue(double num, double expected) {      double result = 0.0;      try {                   // We may throw a        result = mySqrt(num); // precondition exception      }      catch (Throwable e) {        if (num < 0.0)        // If input is < 0, then          return;            // we're expecting the        else                 // exception, otherwise          assert(false);      // force a test failure      }      assert(Math.abs(expected-result) < epsilon*expected);    }Then we can call this routine to test our square root function:  The unit tests for a module shouldn't be shoved in some far-away corner of the source tree. They need to be conveniently located. For small projects, you can embed the unit test for a module in the module itself. For larger projects, we suggest moving each test into a subdirectory. Either way, remember that if it isn't easy to find, it won't be used.By making the test code readily accessible, you are providing developers who may use your code with two invaluable resources:Examples of how to use all the functionality of your module1.A means to build regression tests to validate any future changes to the code2.It's convenient, but not always practical, for each class or module to contain its own unit test. In Java, for example, every class can have its own main. In all but the application's main class file, the mainroutine can be used to run unit tests; it will be ignored when the application itself is run. This has the benefit that the code you ship still contains the tests, which can be used to diagnose problems in the field.In C++ you can achieve the same effect (at compile time) by using #ifdef to compile unit test code selectively. For example, here's a very simple unit test in C++, embedded in our module, that checks our square root function using a testValue routine similar to the Java one defined previously:                                        #ifdef _TEST_    int main(int argc, char **argv)    {      argc--; argv++;       // skip program name      if (argc < 2) {       // do standard tests if no args        testValue(-4.0,  0.0);        testValue( 0.0,  0.0);        testValue( 2.0,  1.4142135624);        testValue(64.0,  8.0);        testValue(1.0e7, 3162.2776602);      }      else {                // else use args        double num, expected;        while (argc >= 2) {          num = atof(argv[0]);          expected = atof(argv[1]);          testValue(num,expected);          argc -= 2;          argv += 2;        }      }       return 0;    }    #endif                                        This unit test will either run a minimal set of tests or, if given arguments, allow you to pass data in from the outside world. A shell script could use this ability to run a much more complete set of tests.What do you do if the correct response for a unit test is to exit, or abort the program? In that case, you need to be able to select the test to run, perhaps by specifying an argument on the command line. You'll also need to pass in parameters if you need to specify different starting conditions for your tests.But providing unit tests isn't enough. You must run them, and run them often. It also helps if the class passes its tests once in a while.Using Test HarnessesBecause we usually write a lot of test code, and do a lot of testing, we'll make life easier on ourselves and develop a standard testing harness for the project. The main shown in the previous section is a very simple test harness, but usually we'll need more functionality than that.A test harness can handle common operations such as logging status, analyzing output for expected results, and selecting and running the tests. Harnesses may be GUI driven, may be written in the same target language as the rest of the project, or may be implemented as a combination of makefilesand Perl scripts. A simple test harness sis shown in the answer to Exercise 41 on page 305.In object-oriented languages and environments, you might create a base class that provides these common operations. Individual tests can subclass from that and add specific test code. You could use a standard naming convention and reflection in Java to build a list of tests dynamically. This technique is a nice way of honoring the DRY principleyou don't have to maintain a list of available tests. Butbefore you go off and start writing your own harness, you may want to investigate Kent Beck and ErichGamma's xUnit at [URL 22 ]. They've already done the hard work.Regardless of the technology you decide to use, test harnesses should include the following capabilities:A standard way to specify setup and cleanup A method for selecting individual tests or all available tests A means of analyzing output for expected (or unexpected) results A standardized form of failure reporting Tests should be composable; that is, a test can be composed of subtests of subcomponents to any  depth. We can use this feature to test selected parts of the system or the entire system just as easily, using the same tools.Ad Hoc TestingDuring debugging, we may end up creating some particular tests on-the-fly. These may be as simple as a print statement, or a piece of code entered interactively in a debugging or IDE environment.At the end of the debugging session you need to formalize the adhoc test. If the code broke once, it is likely to break again. Dont't just throw away the test you created; add it to the existing unit test.For example, using JUnit (the Java member of the xUnit family), we might write our square root test as follows:                                            public class JUnitExample extends TestCase {      public JUnitExample(final String name) {        super(name);      }      protected void setUp() {        // Load up test data...        testData.addElement(new dblPair(-4.0,0.0));        testData.addElement(new dblPair(0.0,0.0));        testData.addElement(new dblPair(64.0,8.0));        testData.addElement(new dblPair(Double.MAX_VALUE,                                        1.3407807929942597E154));      }      public void testMySqrt() {        double num, expected,.result = 0.0;        Enumeration enum = testData.element();        while (enum.hasMoreElements()) {          dblPair p = (dblPair)enum.nextElement();          num       = p.getNum();          expected  = p.getExpected();          testValue(num, expected);        }  maintenance costs and help-desk calls.Despite its hacker reputation, the Perl community has a very strong commitment to unit and regression testing. The Perl standard module installation procedure supports a regression test by invoking                                            % make testThere's nothing magic about Perl itself in this regard. Perl makes it easier to collate and analyze testresults to ensure compliance, but the big advantage is simply that it's a standardtests go in aparticular place, and have a certain expected output. Testing is more cultural than technical; we can instill this testing culture in a project regardless of the language being used.Tip 49Test Your Software, or Your Users WillRelated sections include:The Cat Ate My Source Code Orthogonality Design by Contract Refactoring Ruthless Testing Exercises 41.Design a test jig for the blender interface described in the answer to Exercise 17 on  page 289. Write a shell script that will perform a regression test for the blender. You  need to test basic functionality, error and boundary conditions, and any contractual  obligations. What restrictions are placed on changing the speed? Are they being  honored?  I l@ve RuBoard     Some people feel that this is an extreme position. They say that developers routinely rely on thingsthey don't fully understandthe quantum mechanics of integrated circuits, the interrupt structure of theprocessor, the algorithms used to schedule processes, the code in the supplied libraries, and so on.We agree. And we'd feel the same about wizards if they were simply a set of library calls or standardoperating system services that developers could rely on. But they're not. Wizards generate code thatbecomes an integral part of Joe's application. The wizard code is not factored out behind a tidyinterfaceit is interwoven line by line with functionality that Joe writes.[4]  Eventually, it stops being thewizard's code and starts being Joe's. And no one should be producing code they don't fully understand. [4] However, there are other techniques that help manage complexity. We discuss two, beans and AOP,in Orthogonality .Related sections include:Orthogonality Code Generators ChallengesIf you have a GUI-building wizard available, use it to generate a skeleton application. Go through every line of code it produces. Do you understand it all? Could you have produced it yourself? Would you have produced it yourself, or is it doing things you don't need? I l@ve RuBoard    I l@ve RuBoard   Chapter 7. Before the ProjectDo you ever get the feeling that your project is doomed, even before it starts? Sometimes it might be, unless you establish some basic ground rules first. Otherwise, you might as well suggest that it be shut down now, and save the sponsor some money.At the very beginning of a project, you'll need to determine the requirements. Simply listening to users is not enough: read The Requirements Pit to find out more.Conventional wisdom and constraint management are the topics of Solving Impossible Puzzles.Whether you are performing requirements, analysis, coding, or testing, difficult problems will crop up. Most of the time, they won't be as difficult as they first appear to be.When you think you've got the problems solved, you may still not feel comfortable with jumping in and starting. Is it simple procrastination, or is it something more? Not Until You're Ready offers advice on when it may be prudent to listen to that cautionary voice inside your head.Starting too soon is one problem, but waiting too long may be even worse. In The Specification Trap,we'll discuss the advantages of specification by example.Finally, we'll look at some of the pitfalls of formal development processes and methodologies in Circles and Arrows. No matter how well thought out it is, and regardless of which "best practices" it includes, no method can replace thinking.With these critical issues sorted out before the project gets under way, you can be better positioned to avoid "analysis paralysis" and actually begin your successful project.I l@ve RuBoard     The first statement in the list above may have been stated by the users as "Only an employee's supervisors and the personnel department may view that employee's records." Is this statement truly a requirement? Perhaps today, but it embeds business policy in an absolute statement. Policies change regularly, so we probably don't want to hardwire them into our requirements. Our recommendation is to document these policies separately from the requirement, and hyperlink the two. Make the requirement the general statement, and give the developers the policy information as an example of the type of thing they'll need to support in the implementation. Eventually, policy may end up as metadata in the application.This is a relatively subtle distinction, but it's one that will have profound implications for the developers. If the requirement is stated as "Only personnel can view an employee record," the developer may end up coding an explicit test every time the application accesses these files. However, if the statement is "Only authorized users may access an employee record," the developer will probably design and implement some kind of access control system. When policy changes (and it will), only the metadata for that system will need to be updated. In fact, gathering requirements in this way naturally leads you to a system that is well factored to support metadata.The distinctions among requirements, policy, and implementation can get very blurred when user interfaces are discussed. "The system must let you choose a loan term" is a statement of requirement. "We need a list box to select the loan term" may or may not be. If the users absolutely must have a list box, then it is a requirement. If instead they are describing the ability to choose, but are using listboxas an example, then it may not be. The box on page 205 discusses a project that went horribly wrong because the users' interface needs were ignored.It's important to discover the underlying reason why users do a particular thing, rather than just the way they currently do it. At the end of the day, your development has to solve their business problem,not just meet their stated requirements. Documenting the reasons behind requirements will give your team invaluable information when making daily implementation decisions.There's a simple technique for getting inside your users' requirements that isn't used often enough: become a user. Are you writing a system for the help desk? Spend a couple of days monitoring the phones with an experienced support person. Are you automating a manual stock control system? Work in the warehouse for a week.[1]  As well as giving you insight into how the system will really be used, you'd be amazed at how the request "May I sit in for a week while you do your job?" helps build trust and establishes a basis for communication with your users. Just remember not to get in the way! [1] Does a week sound like a long time? It really isn't, particularly when you're looking at processes inwhich management and workers occupy different worlds. Management will give you one view of howthings operate, but when you get down on the floor, you'll find a very different realityone that will taketime to assimilate.Tip 52Work with a User to Think Like a User The requirements mining process is also the time to start to build a rapport with your user base, learning their expectations and hopes for the system you are building. See Great Expectations , for more.Documenting RequirementsSo you are sitting down with the users and prying genuine requirements from them. You come acrossa few likely scenarios that describe what the application needs to do. Ever the professional, you wantto write these down and publish a document that everyone can use as a basis for discussionsthedevelopers, the end users, and the project sponsors.That's a pretty wide audience.Ivar Jacobson [Jac94 ] proposed the concept of use cases to capture requirements. They let you describe a particular use of the system not in terms of user interface, but in a more abstract fashion.Unfortunately, Jacobson's book was a little vague on details, so there are now many different opinionson what a use case should be. Is it formal or informal, simple prose or a structured document (like aform)? What level of detail is appropriate (remember we have a wide audience)?Sometimes the Interface Is the SystemIn an article in Wired magazine (January 1999, page 176), producer andmusician Brian Eno described an incredible piece of technologythe ultimatemixing board. It does anything to sound that can be done. And yet, instead ofletting musicians make better music, or produce a recording faster or lessexpensively, it gets in the way; it disrupts the creative process.To see why, you have to look at how recording engineers work. They balancesounds intuitively. Over the years, they develop an innate feedback loopbetween their fingertipssliding faders, rotating knobs, and so on However, theinterface to the new mixer didn't leverage off those abilities. Instead, it forced itsusers to type on a keyboard or click a mouse. The functions it provided werecomprehensive, but they were packaged in unfamiliar and exotic ways. Thefunctions the engineers needed were sometimes hidden behind obscure names,or were achieved with nonintuitive combinations of basic facilities.That environment has a requirement to leverage existing skill sets. While  slavishly duplicating what already exists doesn't allow for progress, we must be able to provide a transition to the future.For example, the recording engineers may have been better served by somesort of touchscreen interfacestill tactile, still mounted as a traditional mixingboard might be, yet allowing the software to go beyond the realm of fixed knobsand switches. Providing a comfortable transition through familiar metaphors isone way to help get buy-in.This example also illustrates our belief that successful tools adapt to the hands that use them. In this case, it is the tools that you build for others that must be adaptable.One way of looking at use cases is to emphasize their goal-driven nature. Alistair Cockburn has a paper that describes this approach, as well as templates that can be used (strictly or not) as a starting place ([Coc97a ], also online at [URL 46 ]). Figure 7.1  on the following page shows an abbreviated example of his template, while Figure 7.2  shows his sample use case. Figure 7.1. Cockburn's use case template  Figure 7.2. A sample use case By using a formal template as an aide-mémoire, you can be sure that you include all the information you need in a use case: performance characteristics, other involved parties, priority, frequency, and various errors and exceptions that can crop up ("nonfunctional requirements"). This is also a great place to record user comments such as "oh, except if we get a xxx condition, then we have to do yyyinstead." The template also serves as a ready-made agenda for meetings with your users. This sort of organization supports the hierarchical structuring of use casesnesting more detailed usecases inside higher-level ones. For example, post debit and post credit both elaborate on post transaction.Use Case DiagramsWorkflow can be captured with UML activity diagrams, and conceptual-level class diagrams can sometimes be useful for modeling the business at hand. But true use cases are textual descriptions, with a hierarchy and cross-links. Use cases can contain hyperlinks to other use cases, and they can be nested within each other.It seems incredible to us that anyone would seriously consider documenting information this dense using only simplistic stick people such as Figure 7.3 . Don't be a slave to any notation; use whatever method best communicates the requirements with your audience. Figure 7.3. UML use casesso simple a child could do it! OverspecifyingA big danger in producing a requirements document is being too specific. Good requirementsdocuments remain abstract. Where requirements are concerned, the simplest statement thataccurately reflects the business need is best. This doesn't mean you can be vagueyou must capturethe underlying semantic invariants as requirements, and document the specific or current workpractices as policy.Requirements are not architecture. Requirements are not design, nor are they the user interface. Requirements are need.Seeing FurtherThe Year 2000 problem is often blamed on short-sighted programmers, desperate to save a few bytes in the days when mainframes had less memory than a modern TV remote control.But it wasn't the programmers' doing, and it wasn't really a memory usage issue. If anything, it was the system analysts' and designers' fault. The Y2K problem came about from two main causes: a failure to see beyond current business practice, and a violation of the DRY principle. Businesses were using the two-digit shortcut long before computers came on the scene. It was common practice. The earliest data processing applications merely automated existing business processes, and simply repeated the mistake. Even if the architecture required two-digit years for data input, reporting, and storage, there should have been an abstraction of a DATE that "knew" the two digits were an abbreviated form of the real date.Tip 53Abstractions Live Longer than DetailsDoes "seeing further" require you to predict the future? No. It means generating statements such asThe system makes active use of an abstraction of DATEs. The system will implement DATE services, such as formatting, storage, and math operations, consistently and universally.The requirements will specify only that dates are used. It may hint that some math may be done on dates. It may tell you that dates will be stored on various forms of secondary storage. These are genuine requirements for a DATE module or class.Just One More Wafer-Thin MintMany projects failures are blamed on an increase in scopealso known as feature bloat, creepingfeaturism, or requirements creep. This is an aspect of the boiled-frog syndrome from Stone Soup and  Boiled Frogs . What can we do to prevent requirements from creeping up on us?In the literature, you will find descriptions of many metrics, such as bugs reported and fixed, defect density, cohesion, coupling, function points, lines of code, and so on. These metrics may be tracked by hand or with software.Unfortunately, not many projects seem to track requirements actively. This means that they have noway to report on changes of scopewho requested a feature, who approved it, total number ofrequests approved, and so on.The key to managing growth of requirements is to point out each new feature's impact on the schedule to the project sponsors. When the project is a year late from initial estimates and accusations start flying, it can be helpful to have an accurate, complete picture of how, and when, requirements growth occurred.It's easy to get sucked into the "just one more feature" maelstrom, but by tracking requirements you can get a clearer picture that "just one more feature" is really the fifteenth new feature added this  month.Maintain a GlossaryAs soon as you start discussing requirements, users and domain experts will use certain terms that have specific meaning to them. They may differentiate between a "client" and a "customer," for example. It would then be inappropriate to use either word casually in the system.Create and maintain a project glossaryone place that defines all the specific terms and vocabularyused in a project. All participants in the project, from end users to support staff, should use theglossary to ensure consistency. This implies that the glossary needs to be widely accessiblea goodargument for Web-based documentation (more on that in a moment).Tip 54Use a Project GlossaryIt's very hard to succeed on a project where the users and developers refer to the same thing by different names or, even worse, refer to different things by the same name.Get the Word OutIn It's All Writing , we discuss publishing of project documents to internal Web sites for easy access by all participants. This method of distribution is particularly useful for requirements documents.By presenting requirements as a hypertext document, we can better address the needs of a diverseaudiencewe can give each reader what they want. Project sponsors can cruise along at a high levelof abstraction to ensure that business objectives are met. Programmers can use hyperlinks to "drilldown" to increasing levels of detail (even referencing appropriate definitions or engineeringspecifications).Web-based distribution also avoids the typical two-inch-thick binder entitled Requirements Analysisthat no one ever reads and that becomes outdated the instant ink hits paper.If it's on the Web, the programmers may even read it.Related sections include:Stone Soup and Boiled Frogs  Good-Enough Software Circles and Arrows It's All Writing Great Expectations ChallengesCan you use the software you are writing? Is it possible to have a good feel for requirements without being able to use the software yourself? Pick a non-computer-related problem you currently need to solve. Generate requirements for a noncomputer solution. Exercises42.Which of the following are probably genuine requirements? Restate those that are not to  make them more useful (if possible) .The response time must be less than 500 ms.1.Dialog boxes will have a gray background.2.The application will be organized as a number of front-end processes and a back-end server.3.If a user enters non-numeric characters in a numeric field, the system will beep and not accept them.4.The application code and data must fit within 256kB.5.I l@ve RuBoard    I l@ve RuBoard   Solving Impossible PuzzlesGordius, the King of Phrygia, once tied a knot that no one could untie. It was said that he who solvedthe riddle of the Gordian Knot would rule all of Asia. So along comes Alexander the Great, who chopsthe knot to bits with his sword. Just a little different interpretation of the requirements, that's all andhe did end up ruling most of Asia.Every now and again, you will find yourself embroiled in the middle of a project when a really tough puzzle comes up: some piece of engineering that you just can't get a handle on, or perhaps some bit of code that is turning out to be much harder to write than you thought. Maybe it looks impossible. But is it really as hard as it seems?Consider real-world puzzlesthose devious little bits of wood, wrought iron, or plastic that seem toturn up as Christmas presents or at garage sales. All you have to do is remove the ring, or fit theT-shaped pieces in the box, or whatever.So you pull on the ring, or try to put the T's in the box, and quickly discover that the obvious solutionsjust don't work. The puzzle can't be solved that way. But even though it's obvious, that doesn't stoppeople from trying the same thingover and overthinking there must be a way.Of course, there isn't. The solution lies elsewhere. The secret to solving the puzzle is to identify the real (not imagined) constraints, and find a solution therein. Some constraints are absolute; others are merely preconceived notions. Absolute constraints must be honored, however distasteful or stupid they may appear to be. On the other hand, some apparent constraints may not be real constraints at all. For example, there's that old bar trick where you take a brand new, unopened champagne bottle and bet that you can drink beer out of it. The trick is to turn the bottle upside down, and pour a small quantity of beer in the hollow in the bottom of the bottle. Many software problems can be just as sneaky.Degrees of FreedomThe popular buzz-phrase "thinking outside the box" encourages us to recognize constraints that might not be applicable and to ignore them.But this phrase isn't entirely accurate. If the "box" is the boundary of constraints and conditions, then the trick is to find the box, which may be considerably larger than you think.The key to solving puzzles is both to recognize the constraints placed on you and to recognize the degrees of freedom you do have, for in those you'll find your solution. This is why some puzzles are so effective; you may dismiss potential solutions too readily.For example, can you connect all of the dots in the following puzzle and return to the starting pointwith just three straight lineswithout lifting your pen from the paper or retracing your steps [Hol78 ]?   I l@ve RuBoard   Not Until You're ReadyHe who hesitates is sometimes saved.James Thurber, The Glass in the FieldGreat performers share a trait: they know when to start and when to wait. The diver stands on the high-board, waiting for the perfect moment to jump. The conductor stands before the orchestra, arms raised, until she senses that the moment is right to start the piece.You are a great performer. You too need to listen to the voice that whispers "wait." If you sit down to start typing and there's some nagging doubt in your mind, heed it.Tip 56Listen to Nagging DoubtsStart When You're ReadyThere used to be a style of tennis coaching called "inner tennis." You'd spend hours hitting balls over the net, not particularly trying for accuracy, but instead verbalizing just where the ball hit relative to some target (often a chair). The idea was that the feedback would train your subconscious and reflexes, so that you improved without consciously knowing how or why.As a developer, you've been doing the same kind of thing during your entire career. You've been trying things and seeing which worked and which didn't. You've been accumulating experience and wisdom. When you feel a nagging doubt, or experience some reluctance when faced with a task, heed it. You may not be able to put your finger on exactly what's wrong, but give it time and your doubts will probably crystallize into something more solid, something you can address. Software development is still not a science. Let your instincts contribute to your performance.Good Judgment or Procrastination?Everyone fears the blank sheet of paper. Starting a new project (or even a new module in an existing project) can be an unnerving experience. Many of us would prefer to put off making the initial commitment of starting. So how can you tell when you're simply procrastinating, rather than responsibly waiting for all the pieces to fall into place?A technique that has worked for us in these circumstances is to start prototyping. Choose an area that you feel will be difficult and begin producing some kind of proof of concept. One of two things will typically happen. Shortly after starting, you may feel that you're wasting your time. This boredom is probably a good indication that your initial reluctance was just a desire to put off the commitment to start. Give up on the prototype, and hack into the real development. On the other hand, as the prototype progresses you may have one of those moments of revelation when you suddenly realize that some basic premise was wrong. Not only that, but you'll see clearly how you can put it right. You'll feel comfortable abandoning the prototype and launching into the project proper. Your instincts were right, and you've just saved yourself and your team a considerable amount of wasted effort.When you make the decision to prototype as a way of investigating your unease, be sure to remember why you're doing it. The last thing you want is to find yourself several weeks into serious development before remembering that you started out writing a prototype.Somewhat cynically, starting work on a prototype might also be more politically acceptable than simply announcing that "I don't feel right about starting" and firing up solitaire.ChallengesDiscuss the fear-of-starting syndrome with your colleagues. Do others experience the same thing? Do they heed it? What tricks do they use to overcome it? Can a group help overcome an individual's reluctance, or is that just peer pressure? I l@ve RuBoard    I l@ve RuBoard   The Specification TrapThe Landing Pilot is the Non-Handling Pilot until the 'decision altitude' call, when the Handling Non-Landing Pilot hands the handling to the Non-Handling Landing Pilot, unless the latter calls 'go-around,' in which case the Handling Non-Landing Pilot continues handling and the Non-Handling Landing Pilot continues non-handling until the next call of 'land' or 'go-around' as appropriate. In view of recent confusions over these rules, it was deemed necessary to restate them clearly.British Airways memorandum, quoted in Pilot Magazine, December 1996Program specification is the process of taking a requirement and reducing it down to the point where aprogrammer's skill can take over. It is an act of communication, explaining and clarifying the world insuch a way as to remove major ambiguities. As well as talking to the developer who will be performingthe initial implementation, the specification is a record for future generations of programmers who willbe maintaining and enhancing the code. The specification is also an agreement with the useracodification of their needs and an implicit contract that the final system will be in line with thatrequirement.Writing a specification is quite a responsibility.The problem is that many designers find it difficult to stop. They feel that unless every little detail is pinned down in excruciating detail they haven't earned their daily dollar.This is a mistake for several reasons. First, it's naive to assume that a specification will ever captureevery detail and nuance of a system or its requirement. In restricted problem domains, there areformal methods that can describe a system, but they still require the designer to explain the meaningof the notation to the end usersthere is still a human interpretation going on to mess things up. Evenwithout the problems inherent in this interpretation, it is very unlikely that the average user knowsgoing in to a project exactly what they need. They may say they have an understanding of therequirement, and they may sign off on the 200-page document you produce, but you can guaranteethat once they see the running system you'll be inundated with change requests.Second, there is a problem with the expressive power of language itself. All the diagramming techniques and formal methods still rely on natural language expressions of the operations to be performed.[2]  And natural language is really not up to the job. Look at the wording of any contract: inan attempt to be precise, lawyers have to bend the language in the most unnatural ways. [2] There are some formal techniques that attempt to express operations algebraically, but thesetechniques are rarely used in practice. They still require that the analysts explain the meaning to the end users.Here's a challenge for you. Write a short description that tells someone how to tie bows in their shoelaces. Go on, try it!If you are anything like us, you probably gave up somewhere around "now roll your thumb andforefinger so that the free end passes under and inside the left lace." It is a phenomenally difficult  ChallengesThe shoelace example mentioned in the text is an interesting illustration of the problems of written descriptions. Did you consider describing the process using diagrams rather than words? Photographs? Some formal notation from topology? Models with wire laces? How would you teach a toddler?Sometimes a picture is worth more than any number of words. Sometimes it is worthless. If you find yourself overspecifying, would pictures or special notations help? How detailed do they have to be? When is a drawing tool better than a whiteboard? I l@ve RuBoard     an in-depth grasp of every aspect of a system, but you should know how the components interact, where the data lives, and what the requirements are.We like to write adaptable, dynamic systems, using metadata to allow us to change the character of applications at runtime. Most current formal methods combine a static object or data model with some kind of event- or activity-charting mechanism. We haven't yet come across one that allows us to illustrate the kind of dynamism we feel systems should exhibit. In fact, most formal methods will lead you astray, encouraging you to set up static relationships between objects that really should be knitted together dynamically. Do Methods Pay Off?In a 1999 CACM article [Gla99b ], Robert Glass reviews the research into the productivity and quality improvements gained using seven different software development technologies (4GLs, structured techniques, CASE tools, formal methods, clean room methodology, process models, and object orientation). He reports that the initial hype surrounding all of these methods was overblown. Although there is an indication that some methods have benefits, these benefits start to manifest themselves only after a significant productivity and quality drop while the technique is adopted and its users train themselves. Never underestimate the cost of adopting new tools and methods. Be prepared to treat the first projects using these techniques as a learning experience.Should We Use Formal Methods?Absolutely. But always remember that formal development methods are just one more tool in thetoolbox. If, after careful analysis, you feel you need to use a formal method, then embrace itbutremember who is in charge. Never become a slave to a methodology: circles and arrows make poormasters. Pragmatic Programmers look at methodologies critically, then extract the best from each andmeld them into a set of working practices that gets better each month. This is crucial. You should workconstantly to refine and improve your processes. Never accept the rigid confines of a methodology asthe limits of your world.Don't give in to the false authority of a method. People may walk into meetings with an acre of class diagrams and 150 use cases, but all that paper is still just their fallible interpretation of requirements and design. Try not to think about how much a tool cost when you look at its output.Tip 59Expensive Too Do Not Produce Better DesignsFormal methods certainly have their place in development. However, if you come across a project where the philosophy is "the class diagram is the application, the rest is mechanical coding," you know you're looking at a waterlogged project team and a long paddle home. Related sections include:The Requirements Pit ChallengesUse case diagrams are part of the UML process for gathering requirements (see The  Requirements Pit ). Are they an effective way of communicating with your users? If not, why are you using them? How can you tell if a formal method is bringing your team benefits? What can you measure? What constitutes an improvement? Can you distinguish between benefits of the tool and increased experience on the part of team members? Where is the break-even point for introducing new methods to your team? How do you evaluate the trade-off between future benefits and current losses of productivity as the tool is introduced? Are tools that work for large projects good for small ones? How about the other way around? I l@ve RuBoard    I l@ve RuBoard   Chapter 8. Pragmatic ProjectsAs your project gets under way, we need to move away from issues of individual philosophy and coding to talk about larger, project-sized issues. We aren't going to go into specifics of project management, but we will talk about a handful of critical areas that can make or break any project.As soon as you have more than one person working on a project, you need to establish some ground rules and delegate parts of the project accordingly. In Pragmatic Teams, we'll show how to do this while honoring the pragmatic philosophy.The single most important factor in making project-level activities work consistently and reliably is to automate your procedures. We'll explain why, and show some real-life examples in Ubiquitous Automation.Earlier, we talked about testing as you code. In Ruthless Testing, we go to the next step ofproject-wide testing philosophy and toolsespecially if you don't have a large QA staff at your beckand call.The only thing that developers dislike more than testing is documentation. Whether you have technical writers helping you or are doing it on your own, we'll show you how to make the chore less painful and more productive in It's All Writing.Success is in the eye of the beholderthe sponsor of the project. The perception of success is whatcounts, and in Great Expectations we'll show you some tricks to delight every project's sponsor.The last tip in the book is a direct consequence of all the rest. In Pride and Prejudice, we encourage you to sign your work, and to take pride in what you do.I l@ve RuBoard    I l@ve RuBoard   Pragmatic TeamsAt Group L, Stoffel oversees six first-rate programmers, a managerial challenge roughly comparable to herding cats.The Washington Post Magazine, June 9, 1985So far in this book we've looked at pragmatic techniques that help an individual be a better programmer. Can these methods work for teams as well?The answer is a resounding "yes!" There are advantages to being a pragmatic individual, but these advantages are multiplied manyfold if the individual is working on a pragmatic team.In this section we'll look briefly at how pragmatic techniques can be applied to teams as a whole. These notes are only a start. Once you've got a group of pragmatic developers working in an enabling environment, they'll quickly develop and refine their own team dynamics that work for them.Let's recast some of the previous sections in terms of teams.No Broken WindowsQuality is a team issue. The most diligent developer placed on a team that just doesn't care will find it difficult to maintain the enthusiasm needed to fix niggling problems. The problem is further exacerbated if the team actively discourages the developer from spending time on these fixes.Teams as a whole should not tolerate broken windowsthose small imperfections that noone fixes. The team must take responsibility for the quality of the product, supporting developers who understand the no broken windows philosophy we describe in Software  Entropy , and encouraging those who haven't yet discovered it.Some team methodologies have a quality officersomeone to whom the team delegatesthe responsibility for the quality of the deliverable. This is clearly ridiculous: quality cancome only from the individual contributions of all team members.  When you start a project, come up with a name for it, ideally something off-the-wall. (In the past, we've named projects after things such as killer parrots that prey on sheep, optical illusions, and mythical cities.) Spend 30 minutes coming up with a zany logo, and use it on your memos and reports. Use your team's name liberally when talking with people. It sounds silly, but it gives your team an identity to build on, and the world something memorable to associate with your work.Don't Repeat YourselfIn The Evils of Duplication , we talked about the difficulties of eliminating duplicated work between members of a team. This duplication leads to wasted effort, and can result in a maintenance nightmare. Clearly good communication can help here, but sometimes something extra is needed.Some teams appoint a member as the project librarian, responsible for coordinating documentation and code repositories. Other team members can use this person as the first port of call when they're looking for something. A good librarian will also be able to spot impending duplication by reading the material that they're handling.When the project's too big for one librarian (or when no one wants to play the role), appoint people as focal points for various functional aspects of the work. If people want to talk over date handling, they should know to talk with Mary. If there's a database schema issue, see Fred.And don't forget the value of groupware systems and local Usenet news-groups for communicating and archiving questions and answers.OrthogonalityTraditional team organization is based on the old-fashioned waterfall method of software construction. Individuals are assigned roles based on their job function. You'll find business analysts, architects, designers, programmers, testers, documenters, and the like.[2]  Thereis an implicit hierarchy herethe closer to the user you're allowed, the more senior youare. [2] In The Rational Unified Process: An Introduction, the author identifies 27 separate roles within a project team! [Kru98 ]Taking things to the extreme, some development cultures dictate strict divisions of  responsibility; coders aren't allowed to talk to testers, who in turn aren't allowed to talk to the chief architect, and so on. Some organizations then compound the problem by having different sub-teams report through separate management chains.It is a mistake to think that the activities of a projectanalysis, design, coding, andtestingcan happen in isolation. They can't. These are different views of the sameproblem, and artificially separating them can cause a boatload of trouble. Programmerswho are two or three levels removed from the actual users of their code are unlikely to beaware of the context in which their work is used. They will not be able to make informeddecisions.Tip 60Organize Around Functionality, Not Job FunctionsWe favor splitting teams functionally. Divide your people into small teams, each responsible for a particular functional aspect of the final system. Let the teams organize themselves internally, building on individual strengths as they can. Each team has responsibilities to others in the project, as defined by their agreed-upon commitments. The exact set of commitments changes with each project, as does the allocation of people into teams.Functionality here does not necessarily mean end-user use cases. The database accesslayer counts, as does the help subsystem. We're looking for cohesive, largelyself-contained teams of peopleexactly the same criteria we should be using when wemodularize code. There are warning signs that the team organization is wronga classicexample is having two subteams working on the same program module or class.How does this functional style of organization help? Organize our resources using the same techniques we use to organize code, using techniques such as contracts (Design by  Contract ), decoupling (Decoupling and the Law of Demeter ), and orthogonality (Orthogonality ), and we help isolate the team as a whole from the effects of change. If the user suddenly decides to change database vendors, only the database team should be affected. Should marketing suddenly decide to use an off-the-shelf tool for the calendar function, the calendar group takes a hit. Properly executed, this kind of group approach can dramatically reduce the number of interactions between individuals' work, reducing time  scales, increasing quality, and cutting down on the number of defects. This approach can also lead to a more committed set of developers. Each team knows that they alone are responsible for a particular function, so they feel more ownership of their output.However, this approach works only with responsible developers and strong projectmanagement. Creating a pool of autonomous teams and letting them loose withoutleadership is a recipe for disaster. The project needs at least two "heads"one technical,the other administrative. The technical head sets the development philosophy and style,assigns responsibilities to teams, and arbitrates the inevitable "discussions" betweenpeople. The technical head also looks constantly at the big picture, trying to find anyunnecessary commonality between teams that could reduce the orthogonality of the overalleffort. The administrative head, or project manager, schedules the resources that theteams need, monitors and reports on progress, and helps decide priorities in terms ofbusiness needs. The administrative head might also act as the team's ambassador whencommunicating with the outside world.Teams on larger projects need additional resources: a librarian who indexes and stores code and documentation, a tool builder who provides common tools and environments, operational support, and so on.This type of team organization is similar in spirit to the old chief programmer team concept, first documented in 1972 [Bak72 ].AutomationA great way to ensure both consistency and accuracy is to automate everything the team does. Why lay code out manually when your editor can do it automatically as you type? Why complete test forms when the overnight build can run tests automatically?Automation is an essential component of every project teamimportant enough for us todedicate an entire section to it, starting on the following page. To ensure that things getautomated, appoint one or more team members as tool builders to construct and deploy the tools that automate the project drudgery. Have them produce makefiles, shell scripts, editor templates, utility programs, and the like.Know When to Stop Adding PaintRemember that teams are made up of individuals. Give each member the ability to shine in his or her own way. Give them just enough structure to support them and to ensure that the  project delivers against its requirements. Then, like the painter in Good-Enough Software , resist the temptation to add more paint.Related sections include:Software Entropy Stone Soup and Boiled Frogs Good-Enough Software Communicate! The Evils of Duplication Orthogonality Design by Contract Decoupling and the Law of Demeter Ubiquitous Automation ChallengesLook around for successful teams outside the area of software development. What makes them successful? Do they use any of the processes discussed in this section? Next time you start a project, try convincing people to brand it. Give your organization time to become used to the idea, and then do a quick audit to see what difference it made, both within the team and externally. Team Algebra: In school, we are given problems such as "If it takes 4 workers 6 hours to dig a ditch, how long would it take 8 workers?" In real life, however, what factors affect the answer to: "If it takes 4 programmers 6 months to develop an application, how long would it take 8 programmers?" In how many scenarios is the time actually reduced? I l@ve RuBoard      generate a Java file from it, and compile the result.                                                    .SUFFIXES: .Java .class .xml    .xml.java:            perl convert.pl $<  > $@    .Java.class:            $(JAVAC) $(JAVAC_FLAGS) $<Type make test.class, and make will automatically look for a file named test.xml, build a .java file by running a Perl script, and then compile that file to produce test.class.We can use the same sort of rules to generate source code, header files, or documentation automatically from some other form as well (see Code Generators ).Regression TestsYou can also use the makefile to run regression tests for you, either for an individual module or for an entire subsystem. You can easily test the entire project with just one command at the top of the source tree, or you can test an individual module by using the same command in a single directory. See Ruthless Testing , for more on regression testing.Recursive makeMany projects set up recursive, hierarchical for project builds and testing. But be aware of some potential problems.make calculates dependencies between the various targets it has to build. But it can analyze only the dependencies that exist within one single make invocation. In particular, a recursive make has no knowledge of dependencies that other invocations of make may have. If you are careful and precise, you can get theproper results, but it's easy to cause extra work unnecessarilyor miss adependency and not recompile when it's needed.In addition, build dependencies may not be the same as test dependencies, and you may need separate hierarchies. Build AutomationA build is a procedure that takes an empty directory (and a known compilationenvironment) and builds the project from scratch, producing whatever you hope to produceas a final deliverablea CD-ROM master image or a self-extracting archive, for instance.Typically a project build will encompass the following steps.Check out the source code from the repository.1.Build the project from scratch, typically from a top-level makefile. Each build is marked with some form of release or version number, or perhaps a date stamp.2.Create a distributable image. This procedure may entail fixing file ownership and permissions, and producing all examples, documentation, README files, and anything else that will ship with the product, in the exact format that will be required when you ship.[3] [3] If you are producing a CD-ROM in ISO9660 format, for example, you would run theprogram that produces a bit-for-bit image of the 9660 file system. Why wait until the night before you ship to make sure it works?3.Run specified tests (make test).4.For most projects, this level of build is run automatically every night. In this nightly build, you will typically run more complete tests than an individual might run while building some specific portion of the project. The important point is to have the full build run all available tests. You want to know if a regression test failed because of one of today's code changes. By identifying the problem close to the source, you stand a better chance of finding and fixing it.When you don't run tests regularly, you may discover that the application broke due to a code change made three months ago. Good luck finding that one.Final BuildsFinal builds, which you intend to ship as products, may have different requirements from the regular nightly build. A final build may require that the repository be locked, or tagged with the release number, that optimization and debug flags be set differently, and so on. We like to use a separate make target (such as make final) that sets all of these parameters at once. Remember that if the product is compiled differently from earlier versions, then you must test against this version all over again.Automatic AdministriviaWouldn't it be nice if programmers could actually devote all of their time to programming? Unfortunately, this is rarely the case. There is e-mail to be answered, paperwork to be filled out, documents to be posted to the Web, and so on. You may decide to create a shell script to do some of the dirty work, but you still have to remember to run the script when needed.Because memory is the second thing you lose as you age,[4]  we don't want to rely on it tooheavily. We can run scripts to perform procedures for us automatically, based on the content of source code and documents. Our goal is to maintain an automatic, unattended, content-driven workflow. [4] What's the first? I forget.Web Site GenerationMany development teams use an internal Web site for project communication, and we think this is a great idea. But we don't want to spend too much time maintaining the Web site, and we don't want to let it get stale or out of date. Misleading information is worse than no information at all.Documentation that is extracted from code, requirements analyses, design documents, and any drawings, charts, or graphs all need to be published to the Web on a regular basis. Welike to publish these documents automatically as part of the nightly build or as a hook into the source code check-in procedure.However it is done, Web content should be generated automatically from information in the repository and published without human intervention. This is really another application of the DRY principle: information exists in one form as checked-in code and documents. Theview from the Web browser is simply thatjust a view. You shouldn't have to maintain thatview by hand.Any information generated by the nightly build should be accessible on the development Web site: results of the build itself (for example, the build results might be presented as a one-page summary that includes compiler warnings, errors, and current status), regression  tests, performance statistics, coding metrics and any other static analysis, and so on.Approval ProceduresSome projects have various administrative workflows that must be followed. For instance,code or design reviews need to be scheduled and followed through, approvals may need tobe granted, and so on. We can use automationand especially the Web siteto helpease the paperwork burden.Suppose you wanted to automate code review scheduling and approval. You might put a special marker in each source code file:                                                     /* Status: needs_review */A simple script could go through all of the source code and look for all files that had a status of needs_review, indicating that they were ready to be reviewed. You could then post a list of those files as a Web page, automatically send e-mail to the appropriate people, or even schedule a meeting automatically using some calendar software.You can set up a form on a Web page for the reviewers to register approval or disapproval. After the review, the status can be automatically changed to reviewed. Whether you have a code walk-through with all the participants is up to you; you can still do the paperwork automatically. (In an article in the April 1999 CACM, Robert Glass summarizes research that seems to indicate that, while code inspection is effective, conducting reviews in meetings is not [Gla99a ].)The Cobbler's ChildrenThe cobbler's children have no shoes. Often, people who develop software use the poorest tools to do the job.But we have all the raw materials we need to craft better tools. We have cron. We have make, on both Windows and Unix platforms. And we have Perl and other high-level scripting languages for quickly developing custom tools, Web page generators, code generators, test harnesses, and so on.Let the computer do the repetitious, the mundaneit will do a better job of it than wewould. We've got more important and more difficult things to do. Related sections include:The Cat Ate My Source Code The Evils of Duplication The Power of Plain Text Shell Games Debugging Code Generators Pragmatic Teams Ruthless Testing It's All Writing ChallengesLook at your habits throughout the workday. Do you see any repetitive tasks? Do you type the same sequence of commands over and over again?Try writing a few shell scripts to automate the process. Do you always click on the same sequence of icons repeatedly? Can you create a macro to do all that for you? How much of your project paperwork can be automated? Given the high expense of programming staff,[5]  determine how much of the project's budget is being wastedon administrative procedures. Can you justify the amount of time it would take to craft an automated solution based on the overall cost savings it would achieve? [5] For estimating purposes, you can figure an industry average of about US$100,000 perheadthat's salary plus benefits, training, office space and overhead, and so on. I l@ve RuBoard      A unit test is code that exercises a module. We covered this topic by itself in Code That's  Easy to Test . Unit testing is the foundation of all the other forms of testing that we'll discuss in this section. If the parts don't work by themselves, they probably won't work well together. All of the modules you are using must pass their own unit tests before you can proceed.Once all of the pertinent modules have passed their individual tests, you're ready for the next stage. You need to test how all the modules use and interact with each other throughout the system.Integration TestingIntegration testing shows that the major subsystems that make up the project work and play well with each other. With good contracts in place and well tested, any integration issues can be detected easily. Otherwise, integration becomes a fertile breeding ground for bugs. In fact, it is often the single largest source of bugs in the system.Integration testing is really just an extension of the unit testing we've describedonly nowyou're testing how entire subsystems honor their contracts.Validation and VerificationAs soon as you have an executable user interface or prototype, you need to answer an all-important question: the users told you what they wanted, but is it what they need?Does it meet the functional requirements of the system? This, too, needs to be tested. A bug-free system that answers the wrong question isn't very useful. Be conscious of end-user access patterns and how they differ from developer test data (for an example, see the story about brush strokes on page 92).Resource Exhaustion, Errors, and RecoveryNow that you have a pretty good idea that the system will behave correctly under ideal conditions, you need to discover how it will behave under real-world conditions. In the real world, your programs don't have limitless resources; they run out of things. A few limits your code may encounter include:Memory   Usability TestingUsability testing is different from the types of testing discussed so far. It is performed with real users, under real environmental conditions.Look at usability in terms of human factors. Were there any misunderstandings during requirements analysis that need to be addressed? Does the software fit the user like an extension of the hand? (Not only do we want our own tools to fit our hands, but we want the tools we create for users to fit their hands as well.)As with validation and verification, you need to perform usability testing as early as you can, while there is still time to make corrections. For larger projects, you may want to bring in human factors specialists. (If nothing else, it's fun to play with the one-way mirrors).Failure to meet usability criteria is just as big a bug as dividing by zero.How to TestWe've looked at what to test. Now we'll turn our attention to how to test, including:Regression testing Test data Exercising GUI systems Testing the tests Testing thoroughly Design/Methodology TestingCan you test the design of the code itself and the methodology you used to build the software? After a fashion, yes you can. You do this by analyzing metricsmeasurements of various aspects of the code. The simplest metric(and often the least interesting) is lines of codehow big is the code itself?There are a wide variety of other metrics you can use to examine code,   Real-world data comes from some actual source. Possibly it has been collected from an existing system, a competitor's system, or a prototype of some sort. It represents typical user data. The big surprises come as you discover what typical means. This is most likely to reveal defects and misunderstandings in requirements analysis.Synthetic data is artificially generated, perhaps under certain statistical constraints. You may need to use synthetic data for any of the following reasons.You need a lot of data, possibly more than any real-world sample could provide. You might be able to use the real-world data as a seed to generate a larger sample set, and tweak certain fields that need to be unique. You need data to stress the boundary conditions. This data may be completely synthetic: date fields containing February 29, 1999, huge record sizes, or addresses with foreign postal codes. You need data that exhibits certain statistical properties. Want to see what happens if every third transaction fails? Remember the sort algorithm that slows to a crawl when handed presorted data? You can present data in random or sorted order to expose this kind of weakness. Exercising GUI SystemsTesting GUI-intensive systems often requires specialized testing tools. These tools may be based on a simple event capture/playback model, or they may require specially written scripts to drive the GUI. Some systems combine elements of both.Less sophisticated tools enforce a high degree of coupling between the version of software being tested and the test script itself: if you move a dialog box or make a button smaller, the test may not be able to find it, and may fall. Most modern GUI testing tools use a number of different techniques to get around this problem, and try to adjust to minor layout differences.However, you can't automate everything. Andy worked on a graphics system that allowed the user to create and display nondeterministic visual effects which simulated various natural phenomena. Unfortunately, during testing you couldn't just grab a bitmap and compare the output with a previous run, because it was designed to be different every time. For situations such as this one, you may have no choice but to rely on manual interpretation of test results. One of the many advantages of writing decoupled code (see Decoupling and the Law of  Demeter ) is more modular testing. For instance, for data processing applications that have a GUI front end, your design should be decoupled enough so that you can test the application logic without having a GUI present. This idea is similar to testing your subcomponents first. Once the application logic has been validated, it becomes easier to locate bugs that show up with the user interface in place (it's likely that the bugs were created by the user-interface code).Testing the TestsBecause we can't write perfect software, it follows that we can't write perfect test software either. We need to test the tests.Think of our set of test suites as an elaborate security system, designed to sound the alarm when a bug shows up. How better to test a security system than to try to break in?After you have written a test to detect a particular bug, cause the bug deliberately and make sure the test complains. This ensures that the test will catch the bug if it happens for real.Tip 64Use Saboteurs to Test Your TestingIf you are really serious about testing, you might want to appoint a project saboteur. The saboteur's role is to take a separate copy of the source tree, introduce bugs on purpose, and verify that the tests will catch them.When writing tests, make sure that alarms sound when they should.Testing ThoroughlyOnce you are confident that your tests are correct, and are finding bugs you create, how do you know if you have tested the code base thoroughly enough?The short answer is "you don't," and you never will. But there are products on the market   Most testing should be done automatically. It's important to note that by "automatically" we mean that the test results are interpreted automatically as well. See Ubiquitous  Automation , for more on this subject.We like to test as frequently as we can, and always before we check code into the source repository. Some source code control systems, such as Aegis, can do this automatically. Otherwise, we just type                                            % make testUsually, it isn't a problem to run regressions on all of the individual unit tests and integration tests as often as needed.But some tests may not be easily run on a such a frequent basis. Stress tests, for instance,may require special setup or equipment, and some hand holding. These tests may be runless oftenweekly or monthly, perhaps. But it is important that they be run on a regular,scheduled basis. If it can't be done automatically, then make sure it appears on theschedule, with all the necessary resources allocated to the task.Tightening the NetFinally, we'd like to reveal the single most important concept in testing. It is an obvious one, and virtually every textbook says to do it this way. But for some reason, most projects still do not.If a bug slips through the net of existing tests, you need to add a new test to trap it next time.Tip 66Find Bugs OnceOnce a human tester finds a bug, it should be the last time a human tester finds that bug. The automated tests should be modified to check for that particular bug from then on, every time, with no exceptions, no matter how trivial, and no matter how much the   I l@ve RuBoard   It's All WritingThe palest ink is better than the best memory.Chinese ProverbTypically, developers don't give much thought to documentation. At best it is an unfortunate necessity; at worst it is treated as a low-priority task in the hope that management will forget about it at the end of the project.Pragmatic Programmers embrace documentation as an integral part of the overalldevelopment process. Writing documentation can be made easier by not duplicating effortor wasting time, and by keeping documentation close at handin the code itself, ifpossible.These aren't exactly original or novel thoughts; the idea of wedding code and documentation appears in Donald Knuth's work on literate programming and in Sun's JavaDoc utility, among others. We want to downplay the dichotomy between code and documentation, and instead treat them as two views of the same model (see It's Just a  View ). In fact, we want to go a little further and apply all of our pragmatic principles to documentation as well as to code.Tip 67Treat English as Just Another Programming LanguageThere are basically two kinds of documentation produced for a project: internal andexternal. Internal documentation includes source code comments, design and testdocuments, and so on. External documentation is anything shipped or published to theoutside world, such as user manuals. But regardless of the intended audience, or the roleof the writer (developer or technical writer), all documentation is a mirror of the code. Ifthere's a discrepancy, the code is what mattersfor better or worse.Tip 68 Build Documentation In, Don't Bolt It OnWe'll start with internal documentation.Comments in CodeProducing formatted documents from the comments and declarations in source code is fairly straightforward, but first we have to ensure that we actually have comments in the code. Code should have comments, but too many comments can be just as bad as too few.In general, comments should discuss why something is done, its purpose and its goal. The code already shows how it is done, so commenting on this is redundantand is a violationof the DRY principle.Commenting source code gives you the perfect opportunity to document those elusive bits of a project that can't be documented anywhere else: engineering trade-offs, why decisions were made, what other alternatives were discarded, and so on.We like to see a simple module-level header comment, comments for significant data and type declarations, and a brief per-class and per-method header, describing how the function is used and anything that it does that is not obvious.Variable names, of course, should be well chosen and meaningful. foo, for instance, is meaningless, as is doit or manager or stuff. Hungarian notation (where you encode the variable's type information in the name itself) is utterly inappropriate in object-oriented systems. Remember that you (and others after you) will be reading the code many hundreds of times, but only writing it a few times. Take the time to spell out connectionPoolinstead of cp.Even worse than meaningless names are misleading names. Have you ever had someone explain inconsistencies in legacy code such as, "The routine called getData really writesdata to disk"? The human brain will repeatedly foul this upit's called the Stroop Effect[Str35 ]. You can try the following experiment yourself to see the effects of such interference. Get some colored pens, and use them to write down the names of colors.  However, never write a color name using that color pen. You could write the word "blue" in green, the word "brown" in red, and so on. (Alternatively, we have a sample set of colors already drawn on our Web site at http://www.pragmaticprogrammer.com .) Once you have the color names drawn, try to say aloud the color with which each word is drawn, as fast as you can. At some point you'll trip up and start reading the names of the colors, and not the colors themselves. Names are deeply meaningful to your brain, and misleading names add chaos to your code.You can document parameters, but ask yourself if it is really necessary in all cases. The level of comment suggested by the JavaDoc tool seems appropriate:                                            /**      * Find the peak (highest) value within a specified date      * range of samples.      *      * @param  aRange Range of dates to search for data.      * @param  aThreshold Minimum value to consider.      * @return the value, or <code>null</code> if no value found                greater than or equal to the threshold.      */      public Sample findPeak(DateRange aRange, double aThreshold);Here's a list of things that should not appear in source comments.A list of the functions exported by code in the file.   There are programs thatanalyze source for you. Use them, and the list is guaranteed to be up to date. Revision history.   This is what source code control systems are for (see Source  Code Control ). However, it can be useful to include information on the date of last change and the person who made it.[9] [9] This kind of information, as well as the filename, is provided by the RCS $Id$ tag. A list of other files this file uses.   This can be determined more accuratelyusing automatic tools. The name of the file.   If it must appear in the file, don't maintain it by hand. RCSand similar systems can keep this information up to date automatically. If you move or rename the file, you don't want to have to remember to edit the header.  One of the most important pieces of information that should appear in the source file is theauthor's namenot necessarily who edited the file last, but the owner. Attachingresponsibility and accountability to source code does wonders in keeping people honest(see Pride and Prejudice ).The project may also require certain copyright notices or other legal boilerplate to appear in each source file. Get your editor to insert these for you automatically.With meaningful comments in place, tools such as JavaDoc [URL 7 ] and DOC++ [URL 21 ]can extract and format them to automatically produce API-level documentation. This is onespecific example of a more general technique we useexecutable documents.Executable DocumentsSuppose we have a specification that lists the columns in a database table. We'll then have a separate set of SQL commands to create the actual table in the database, and probably some kind of programming language record structure to hold the contents of a row in the table. The same information is repeated three times. Change any one of these three sources, and the other two are immediately out of date. This is a clear violation of the DRYprinciple.To correct this problem, we need to choose the authoritative source of information. This may be the specification, it may be a database schema tool, or it may be some third source altogether. Let's choose the specification document as the source. It's now our model for this process. We then need to find a way to export the information it contains as different viewsa database schema and a high-level language record, for example.[10] [10] See It's Just a View , for more on models and views.If your document is stored as plain text with markup commands (using HTML, LaTeX, or troff, for example), then you can use tools such as Perl to extract the schema and reformat it automatically. If your document is in a word processor's binary format, then see the box on the following page for some options.Your document is now an integral part of the project development. The only way to change the schema is to change the document. You are guaranteeing that the specification, schema, and code all agree. You minimize the amount of work you have to do for each change, and you can update the views of the change automatically. What if My Document Isn't Plain Text?Unfortunately, more and more project documents are now being written using world processors that store the file on disk in some proprietary format. We say "unfortunately" because this severely restricts your options to process the document automatically. However, you still have a couple of options:Write macros.   Most sophisticated word processors now have a macrolanguage. With some effort you can program them to export tagged sections of your documents into the alternative forms you need. If programming at this level is too painful, you could always export the appropriate section into a standard format plain text file, and then use a tool such as Perl to convert this into the final forms. Make the document subordinate.   Rather than have the documentas the definitive source, use another representation. (In the database example, you might want to use the schema as the authoritative information.) Then write a tool that exports this information into a form that the document can import. Be careful, however. You need to ensure that this information is imported every time the document is printed, rather than just once when the document is created. We can generate API-level documentation from source code using tools such as JavaDocand DOC++ in a similar fashion. The model is the source code: one view of the model canbe compiled; other views are meant to be printed out or viewed on the Web. Our goal isalways to work on the modelwhether the model is the code itself or some otherdocumentand have all views updated automatically (see Ubiquitous Automation , for more on automatic processes).Suddenly, documentation isn't so bad.Technical WritersUp until now, we've talked only about internal documentationwritten by the programmersthemselves. But what happens when you have professional technical writers involved in theproject? All too often, programmers just throw material "over the wall" to technical writers and let them fend for themselves to produce user manuals, promotional pieces, and so on.This is a mistake. Just because programmers aren't writing these documents doesn't meanthat we can forsake pragmatic principles. We want the writers to embrace the same basicprinciples that a Pragmatic Programmer doesespecially honoring the DRY principle, orthogonality, the model-view concept, and the use of automation and scripting.Print It or Weave ItOne problem inherent with published, paper documentation is that it can become out of date as soon as it's printed. Documentation of any form is just a snapshot.So we try to produce all documentation in a form that can be published online, on the Web, complete with hyperlinks. It's easier to keep this view of the documentation up to date than to track down every existing paper copy, burn it, and reprint and redistribute new copies. It's also a better way to address the needs of a wide audience. Remember, though, to put a date stamp or version number on each Web page. This way the reader can get a good idea of what's up to date, what's changed recently, and what hasn't.Many times you need to present the same documentation in different formats: a printed document, Web pages, online help, or perhaps a slide show. The typical solution relies heavily on cut-and-paste, creating a number of new independent documents from the original. This is a bad idea: a document's presentation should be independent of its content.If you are using a markup system, you have the flexibility to implement as many different output formats as you need. You can choose to have                                            <H1>Chapter Title</H1>generate a new chapter in the report version of the document and title a new slide in the slide show. Technologies such as XSL and CSS[11]  can be used to generate multiple outputformats from this one markup. [11] eXtensible Style Language and Cascading Style Sheets, two technologies designed to help separatepresentation from content.If you are using a word processor, you'll probably have similar capabilities. If you remembered to use styles to identify different document elements, then by applying  different style sheets you can drastically alter the look of the final output. Most word processors now allow you to convert your document to formats such as HTML for Web publishing.Markup LanguagesFinally, for large-scale documentation projects, we recommend looking at some of the more modern schemes for marking up documentation.Many technical authors now use DocBook to define their documents. DocBook is an SGML-based markup standard that carefully identifies every component in a document. The document can be passed through a DSSSL processor to render it into any number of different formats. The Linux documentation project uses DocBook to publish information in RTF,  , info, PostScript, and HTML formats.As long as your original markup is rich enough to express all the concepts you need(including hyperlinks), translation to any other pub-lishable form can be both easy andautomatic. You can produce online help, published manuals, product highlights for the Website, and even a tip-a-day calendar, all from the same sourcewhich of course is undersource control and is built along with the nightly build (see Ubiquitous Automation ).Documentation and code are different views of the same underlying model, but the view is all that should be different. Don't let documentation become a second-class citizen, banished from the main project workflow. Treat documentation with the same care you treat code, and the users (and maintainers who follow) will sing your praises.Related sections include:The Evils of Duplication Orthogonality The Power of Plain Text Source Code Control It's Just a View Programming by Coincidence  The Requirements Pit Ubiquitous Automation ChallengesDid you write an explanatory comment for the source code you just wrote? Whynot? Pressed for time? Not sure if the code will really workare you just trying outan idea as a prototype? You'll throw the code away afterwards, right? It won't makeit into the project uncommented and experimental, will it? Sometimes it is uncomfortable to document the design of source code because the design isn't clear in your mind; it's still evolving. You don't feel that you should waste effort describing what something does until it actually does it. Does this sound like programming by coincidence (page 172)? I l@ve RuBoard    I l@ve RuBoard   Great ExpectationsBe astonished, O ye heavens, at this, and be horribly afraidJeremiah 2:12A company announces record profits, and its share price drops 20%. The financial newsthat night explains that the company failed to meet analysts' expectations. A child opens anexpensive Christmas present and bursts into tearsit wasn't the cheap doll the child washoping for. A project team works miracles to implement a phenomenally complexapplication, only to have it shunned by its users because it doesn't have a help system.In an abstract sense, an application is successful if it correctly implements its specifications. Unfortunately, this pays only abstract bills.In reality, the success of a project is measured by how well it meets the expectations of its users. A project that falls below their expectations is deemed a failure, no matter how good the deliverable is in absolute terms. However, like the parent of the child expecting the cheap doll, go too far and you'll be a failure, too.Tip 69Gently Exceed Your Users' ExpectationsHowever, the execution of this tip requires some work.Communicating ExpectationsUsers initially come to you with some vision of what they want. It may be incomplete, inconsistent, or technically impossible, but it is theirs, and, like the child at Christmas, they have some emotion invested in it. You cannot just ignore it.As your understanding of their needs develops, you'll find areas where their expectations cannot be met, or where their expectations are perhaps too conservative. Part of your role  is to communicate this. Work with your users so that their understanding of what you'll be delivering is accurate. And do this throughout the development process. Never lose sight of the business problems your application is intended to solve.Some consultants call this process "managing expectations"actively controlling whatusers should hope to get from their systems. We think this is a somewhat elitist position.Our role is not to control the hopes of our users. Instead, we need to work with them tocome to a common understanding of the development process and the final deliverable,along with those expectations they have not yet verbalized. If the team is communicatingfluently with the outside world, this process is almost automatic; everyone shouldunderstand what's expected and how it will be built.There are some important techniques that can be used to facilitate this process. Of these, Tracer Bullets , and Prototypes and Post-it Notes , are the most important. Both let the team construct something that the user can see. Both are ideal ways of communicating your understanding of their requirements. And both let you and your users practice communicating with each other.The Extra MileIf you work closely with your users, sharing their expectations and communicating what you're doing, then there will be few surprises when the project gets delivered.This is a BAD THING. Try to surprise your users. Not scare them, mind you, but delightthem.Give them that little bit more than they were expecting. The extra bit of effort it requires to add some user-oriented feature to the system will pay for itself time and time again in goodwill.Listen to your users as the project progresses for clues about what features would really delight them. Some things you can add relatively easily that look good to the average user include:Balloon or ToolTip help Keyboard shortcuts A quick reference guide as a supplement to the user's manual  Colorization Log file analyzers Automated installation Tools for checking the integrity of the system The ability to run multiple versions of the system for training A splash screen customized for their organization All of these things are relatively superficial, and don't really overburden the system with feature bloat. However, each tells your users that the development team cared about producing a great system, one that was intended for real use. Just remember not to break the system adding these new features.Related sections include:Good-Enough Software Tracer Bullets Prototypes and Post-it Notes The Requirements Pit ChallengesSometimes the toughest critics of a project are the people who worked on it. Have you ever experienced disappointment that your own expectations weren't met by something you produced? How could that be? Maybe there's more than logic at work here. What do your users comment on when you deliver software? Is their attention to the various areas of the application proportional to the effort you invested in each? What delights them? I l@ve RuBoard    I l@ve RuBoard   Pride and PrejudiceYou have delighted us long enough.Jane Austen, Pride and PrejudicePragmatic Programmers don't shirk from responsibility. Instead, we rejoice in accepting challenges and in making our expertise well known. If we are responsible for a design, or a piece of code, we do a job we can be proud of.Tip 70Sign Your WorkCraftsmen of an earlier age were proud to sign their work. You should be, too.Project teams are still made up of people, however, and this rule can cause trouble. On some projects, the idea of code ownership can cause cooperation problems. People may become territorial, or unwilling to work on common foundation elements. The project may end up like a bunch of insular little fiefdoms. You become prejudiced in favor of your code and against your coworkers.That's not what we want. You shouldn't jealously defend your code against interlopers; by the same token, you should treat other people's code with respect. The Golden Rule ("Do unto others as you would have them do unto you") and a foundation of mutual respect among the developers is critical to make this tip work.Anonymity, especially on large projects, can provide a breeding ground for sloppiness, mistakes, sloth, and bad code. It becomes too easy to see yourself as just a cog in the wheel, producing lame excuses in endless status reports instead of good code.While code must be owned, it doesn't have to be owned by an individual. In fact, Kent Beck's successful eXtreme Programming method [URL 45 ] recommends communal ownership of code (but this also requires additional practices, such as pair programming, to  guard against the dangers of anonymity).We want to see pride of ownership. "I wrote this, and I stand behind my work." Your signature should come to be recognized as an indicator of quality. People should see your name on a piece of code and expect it to be solid, well written, tested, and documented. A really professional job. Written by a real professional.A Pragmatic Programmer.I l@ve RuBoard    I l@ve RuBoard   Appendix A. ResourcesThe only reason we were able to cover so much ground in this book is that we viewed many of our subjects from a high altitude. If we'd given them the in-depth coverage they deserved, the book would have been ten times longer.We started the book with the suggestion that Pragmatic Programmers should always be learning. In this appendix we've listed resources that may help you with this process.In the section Professional Societies , we give details of the IEEE and the ACM. We recommend that Pragmatic Programmers join one (or both) of these societies. Then, in Building a Library, we highlight periodicals, books, and Web sites that we feel contain high-quality and pertinent information (or that are just plain fun).Throughout the book we referenced many software resources accessible via the Internet. In the Internet Resources  section, we list the URLs of these resources, along with a short description of each. However, the nature of the Web means that many of these links may well be stale by the time you read this book. You could try one of the many search engines for a more up-to-date link, or visit our Web site at www.pragmaticprogrammer.com  and check our links section.Finally, this appendix contains the book's bibliography.I l@ve RuBoard    I l@ve RuBoard   Professional SocietiesThere are two world-class professional societies for programmers: the Association for Computing Machinery (ACM)[1]  and the IEEE Computer Society.[2]  We recommend that allprogrammers belong to one (or both) of these societies. In addition, developers outside the United States may want to join their national societies, such as the BCS in the United Kingdom. [1] ACM Member Services, PO Box 11414, New York, NY 10286, USA.www.acm.org [2] 1730 Massachusetts Avenue NW, Washington, DC 20036-1992, USA.www.computer.org Membership in a professional society has many benefits. The conferences and local meetings give you great opportunities to meet people with similar interests, and the special interest groups and technical committees give you the opportunity to participate in setting standards and guidelines used around the world. You'll also get a lot out of their publications, from high-level discussions of industry practice to low-level computing theory.I l@ve RuBoard    I l@ve RuBoard   Building a LibraryWe're big on reading. As we noted in Your Knowledge Portfolio , a good programmer is always learning. Keeping current with books and periodicals can help. Here are some that we like.PeriodicalsIf you're like us, you'll save old magazines and periodicals until they're piled high enough to turn the bottom ones to flat sheets of diamond. This means it's worth being fairly selective. Here are a few periodicals we read.IEEE Computer.   Sent to members of the IEEE Computer Society, Computerhas a practical focus but is not afraid of theory. Some issues are oriented around a theme, while others are simply collections of interesting articles. This magazine has a good signal-to-noise ratio. IEEE Software.   This is another great bimonthly publication of the IEEE ComputerSociety aimed at software practitioners. Communications of the ACM.   The basic magazine received by all members ofthe ACM, CACM has been a standard in the industry for decades, and has probably published more seminal articles than any other source. SIGPLAN.   Produced by the ACM Special Interest Group on ProgrammingLanguages, SIGPLAN is an optional addition to your ACM membership. It is often used for publishing language specifications, along with articles of interest to everyone who likes looking deeply into programming. Dr. Dobbs Journal.   A monthly magazine, available by subscription and onnewsstands, Dr. Dobbs is quirky, but has articles ranging from bit-level practice to heavy theory. The Perl Journal.   If you like Perl, you should probably subscribe to The Perl Journal (www.tpj.com ). Software Development Magazine.   A monthly magazine focusing on general  issues of project management and software development.Weekly Trade PapersThere are several weekly newspapers published for developers and their managers. Thesepapers are largely a collection of company press releases, redressed as articles. However,the content is still valuableit lets you track what is going on, keep abreast of new productannouncements, and follow industry alliances as they are forged and broken. Don't expecta lot of in-depth technical coverage, though.BooksComputing books can be expensive, but choose carefully and they're a worthwhile investment. Here are a handful of the many we like.Analysis and DesignObject-Oriented Software Construction, 2nd Edition.   Bertrand Meyer's epicbook on the fundamentals of object-oriented development, all in about 1,300 pages [Mey97b ]. Design Patterns.   A design pattern describes a way to solve a particular class ofproblems at a higher level than a programming language idiom. This now-classic book [GHJV95 ] by the Gang of Four describes 23 basic design patterns, including Proxy, Visitor, and Singleton. Analysis Patterns.   A treasure trove of high-level, architectural patterns takenfrom a wide variety of real-world projects and distilled in book form. A relatively quick way to gain the insight of many years of modeling experience [Fow96 ]. Teams and ProjectsThe Mythical Man Month.   Fred Brooks' classic on the perils of organizingproject teams, recently updated [Bro95 ]. Dynamics of Software Development.   A series of short essays on buildingsoftware in large teams, focusing on the dynamics between team members, and between the team and the rest of the world [McC95 ].   www.cetus-links.org WikiWikiWeb.   The Portland Pattern Repository and patterns discussion. Not justa great resource, the WikiWikiWeb site is an interesting experiment in collective editing of ideas.www.c2.com I l@ve RuBoard    I l@ve RuBoard   Internet ResourcesThe links below are to resources available on the Internet. They were valid at the time of writing, but (the Net being what it is) they may well be out of date by the time you read this. If so, you could try a general search for the filenames, or come to the Pragmatic Programmer Web site (www.pragmaticprogrammer.com ) and follow our links.EditorsEmacs and vi are not the only cross-platform editors, but they are freely available and widely used. A quick scan through a magazine such as Dr. Dobbs will turn up several commercial alternatives.EmacsBoth Emacs and XEmacs are available on Unix and Windows platforms.[URL l] The Emacs Editorwww.gnu.org The ultimate in big editors, containing every feature that any editor has everhad, Emacs has a near-vertical learning curve, but repays handsomelyonce you've mastered it. It also makes a great mall and news reader,address book, calendar and diary, adventure game, .[URL 2] The XEmacs Editorwww.xemacs.org Spawned from the original Emacs some years ago, XEmacs is reputed to have cleaner internals and a better-looking interface.vi  [URL 7] The Java Language from Sunjava.sun.com Home of Java, including downloadable SDKs, documentation, tutorials, news, and more. [URL 8] Perl Language Home Pagewww.perl.com O'Reilly hosts this set of Peri-related resources. [URL 9] The Python Languagewww.python.org The Python object-oriented programming language is interpreted and interactive, with a slightly quirky syntax and a wide and loyal following. [URL 10] SmallEiffelSmallEiffel.loria.fr The GNU Eiffel compiler runs on any machine that has an ANSI C compiler and a Posix runtime environment. [URL 11] ISE Eiffelwww.eiffel.com  Interactive Software Engineering is the originator of Design by Contract, and sells a commercial Eiffel compiler and related tools. [URL 12] Satherwww.icsi.berkeley.edu/~sather Sather is an experimental language that grew out of Eiffel. It aims to support higher-order functions and iteration abstraction as well as Common Lisp, CLU, or Scheme, and to be as efficient as C, C++, or Fortran. [URL 13] VisualWorkswww.objectshare.com Home of the VisualWorks Smalltalk environment. Noncommercial versions for Windows and Linux are available for free. [URL 14] The Squeak Language Environmentsqueak.cs.uiuc.edu Squeak is a freely available, portable implementation of Smalltalk-80 written in itself; it can produce C code output for higher performance. [URL 15] The TOM Programming Languagewww.gerbil.org/tom A very dynamic language with roots in Objective-C. [URL 16] The Beowulf Projectwww.beowulf.org A project that builds high-performance computers out of networked clusters of inexpensive Linux boxes. [URL 17] iContractDesign by Contract Tool for Javawww.reliable-systems.com Design by Contract formalism of preconditions, postconditions, and invariants, implemented as a preprocessor for Java. Honors inheritance, implements existential quantifiers, and more. [URL 18] NanaLogging and Assertions for C and C++www.cs.ntu.edu.au/homepages/pjm/nana-home/index.html Improved support for assertion checking and logging in C and C++. It also provides some support for Design by Contract. [URL 19] DDDData Display Debuggerwww.cs.tu-bs.de/softech/ddd A free graphical front end for Unix debuggers. [URL 20] John Brant's Refactoring Browserst-www.cs.uiuc.edu/users/brant/Refactory  A popular refactoring browser for Smalltalk. [URL 21 ] DOC++ Documentation Generatorwww.zib.de/Visual/software/doc++/index.html DOC++ is a documentation system for C/C++ and Java that generates both  and HTML output for sophisticated online browsing of yourdocumentation directly from the C++ header or Java class flies. [URL 22] xUnitUnit Testing Frameworkwww.XProgranming.com A simple but powerful concept, the xUnit unit testing framework provides a consistent platform for testing software written in a variety of languages. [URL 23] The Tcl Languagewww.scriptics.com Tcl ("Tool Command Language") is a scripting language designed to be easy to embed into an application. [URL 24] ExpectAutomate Interaction with Programsexpect.nist.gov An extension built on Tcl [URL 23 ], expect allows you to script interaction with programs. As well as helping you write command flies that (for example) fetch files from remote servers or extend the power of your shell,   SWIG is a software development tool that connects programs written in C, C++, and Objective-C with a variety of high-level programming languages such as Perl, Python, and Tcl/Tk, as well as Java, Eiffel, and Guile. [URL 29] The Object Management Group, Inc.www.omg.org The OMG is the steward of various specifications for producing distributed object-based systems. Their work includes the Common Object Request Broker Architecture (CORBA) and the Internet Inter-ORB Protocol (IIOP). Combined, these specifications make it possible for objects to communicate with each other, even if they are written in different languages and run on different types of computers.Unix Tools Under DOS [URL 30] The UWIN Development Toolswww.gtlinc.com/Products/Uwin/uwin.html Global Technologies, Inc., Old Bridge, NJThe UWIN package provides Windows Dynamic Link Libraries (DLLs) that emulate a large portion of the Unix C level library interface. Using this interface, GTL has ported a large number of Unix command-line tools to Windows. See also [URL 31 ]. [URL 31 ] The Cygnus Cygwin Toolssourceware.cygnus.com/cygwin/ Cygnus Solutions, Sunnyvale, CA The Cygnus package also emulates the the Unix C library interface, and provides a large array of Unix command-line tools under the Windows operating system. [URL 32] Perl Power Toolswww.perl.com/pub/language/ppt/ A project to reimplement the classic Unix command set in Perl, making the commands available on all platforms that support Perl (and that's a lot of platforms).Source Code Control Tools[URL 33] RCSRevision Control Systemprep.ai.mit.edu GNU source code control system for Unix and Windows NT.[URL 34] CVSConcurrent Version Systemwww.cvshome.com Freely available source code control system for Unix and Windows NT. Extends RCS by supporting a client-server model and concurrent access to files.[URL 35] Aegis Transaction-Based Configuration Managementhttp://www.canb.auug.org.au/~millerp/aegis.html A process-oriented revision control tool that imposes project standards (such as verifying that checked-in code passes tests).[URL 36] ClearCase www.rational.com Version control, workspace and build management, process control.[URL 37] MKS Source Integritywww.mks.com Version control and configuration management. Some versions incorporate features allowing remote developers to work on the same files simultaneously (much like CVS).[URL 38] PVCS Configuration Managementwww.merant.com A source code control system, very popular for Windows systems.[URL 39] Visual SourceSafewww.microsoft.com A version control system that integrates with Microsoft's visual development tools.[URL 40] Perforcewww.perforce.com A client-server software configuration management system.Other Tools [URL 41] WinZipArchive Utility for Windowswww.winzip.com  Nico Mak Computing, Inc., Mansfield, CTA Windows-based file archive utility. Supports both zip and tar formats.[URL 42] The Z Shellsunsite.auc.dk/zsh A shell designed for interactive use, although it is also a powerful scripting language. Many of the useful features of bash, ksh, and tcsh were incorporated into zsh; many original features were added.[URL 43] A Free SMB Client for Unix Systemssamba.anu.edu.au/pub/samba/ Samba lets you share files and other resources between Unix and Windows systems. Samba includes:An SMB server, to provide Windows NT and LAN Manager-style file and print services to SMB clients such as Windows 95, Warp Server, smbfs, and others. A Netbios nameserver, which among other things gives browsing support. Samba can be the master browser on your LAN if you wish. An ftp-like SMB client that allows you to access PC resources (disks and printers) from Unix, Netware, and other operating systems. Papers and Publications[URL 44] The comp.object FAQwww.cyberdyne-object-sys.com/oofaq2 A substantial and well-organized FAQ for the comp.object newsgroup.   [URL 49] Aspect-Oriented Programmingwww.pare.xerox.com/csl/projects/aop/ An approach to adding functionality to code, both orthogonally and declaratively. [URL 50] JavaSpaces Specificationjava.sun.com/products/javaspaces A Linda-like system for Java that supports distributed persistence and distributed algorithms. [URL 51] Netscape Source Codewww.mozilla.org The development source of the Netscape browser. [URL 52] The Jargon Filewww.jargon.org Eric S. RaymondDefinitions for many common (and not so common) computer industry terms, along with a good dose of folklore.[URL 53] Eric S. Raymond's Paperswww.tuxedo.org/~esr   Free Software Foundation, Boston, MAThe Free Software Foundation is a tax-exempt charity that raises funds for the GNU project. The GNU project's goal is to produce a complete, free, Unix-like system. Many of the tools they've developed along the way have become industry standards. [URL 58] Web Server Informationwww.netcraft.com/survey/servers.html Links to the home pages of over 50 different web servers. Some are commercial products, while others are freely available.I l@ve RuBoard    I l@ve RuBoard   Bibliography[Bak72] F. T. Baker. Chief programmer team management of production programming. IBM Systems Journal, ll(l):5673, 1972.[Bbm96] V. Basili, L. Briand, and W. L. Melo. A validation of object-oriented design metrics as qualityindicators. IEEE Transactions on Software Engineering, 22(10):751761, October 1996.[Ber96] Albert J. Bernstein. Dinosaur Brains: Dealing with All Those Impossible People at Work.Ballantine Books, New York, NY, 1996.[Bra95] Marshall Brain. Win32 System Services. Prentice Hall, Englewood Cliffs, NJ, 1995.[Bro95] Frederick P. Brooks Jr. The Mythical Man Month: Essays on Software Engineering.Addison-Wesley, Reading, MA, anniversary edition, 1995.[CG90] N. Carriero and D. Gelenter. How to Write Parallel Programs: A First Course. MIT Press,Cambridge, MA, 1990.[CN91] Brad J. Cox and Andrex J. Novobilski. Object-Oriented Programming, An Evolutionary Approach. Addison-Wesley, Reading, MA, 1991.[Coc97a] Alistair Cockburn. Goals and use cases. Journal of Object Oriented Programming,9(7):3540, September 1997.[Coc97b] Alistair Cockburn. Surviving Object-Oriented Projects: A Manager's Guide. Addison WesleyLongman, Reading, MA, 1997.[Cop92] James O. Coplien. Advanced C++ Programming Styles and Idioms. Addison-Wesley,Reading, MA, 1992.[DL99] Tom Demarco and Timothy Lister. Peopleware: Productive Projects and Teams. Dorset House,New York, NY, second edition, 1999..[FBB+99] Martin Fowler, Kent Beck, John Brant, William Opdyke and Don Roberts. Refactoring: Improving the Design of Existing Code. Addison Wesley Longman, Reading, MA, 1999.[Fow96] Martin Fowler. Analysis Patterns: Reusable Object Models. Addison Wesley Longman,Reading, MA, 1996.[FS97] Martin Fowler and Kendall Scott. UML Distilled: Applying the Standard Object Modeling Language. Addison Wesley Longman, Reading, MA, 1997.[GHJV95] Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, Reading, MA, 1995. [Gla99a] Robert L. Glass. InspectionsSome surprising findings. Communications of the ACM, 42(4):1719, April 1999.[Gla99b] Robert L. Glass. The realities of software technology payoffs. Communications of the ACM,42(2):7479, February 1999.[Hol78] Michael Holt. Math Puzzles and Games. Dorset Press, New York, NY, 1978.[Jac94] Ivar Jacobson. Object-Oriented Software Engineering: A Use-Case Driven Approach.Addison-Wesley, Reading, MA, 1994.[KLM+97] Gregor Kiczales, John Lamping, Anurag Mendhekar, Chris Maeda, Cristina Videira Lopes,Jean-Marc Loingtier and John Irwin. Aspect-oriented programming. In European Conference on Object-Oriented Programming (ECOOP), volume LNCS 1241. Springer-Verlag, June 1997.[Knu97a] Donald Ervin Knuth. The Art of Computer Programming: Fundamental Algorithms, volume 1.Addison Wesley Longman, Reading, MA, third edition, 1997.[Knu97b] Donald Ervin Knuth. The Art of Computer Programming: Seminumerical Algorithms, volume2. Addison Wesley Longman, Reading, MA, third edition, 1997.[Knu98] Donald Ervin Knuth. The Art of Computer Programming: Sorting and Searching, volume 3.Addison Wesley Longman, Reading, MA, second edition, 1998.[KP99] Brian W. Kernighan and Rob Pike. The Practice of Programming. Addison Wesley Longman,Reading, MA, 1999.[Kru98] Philippe Kruchten. The Rational Unified Process: An Introduction. Addison Wesley Longman,Reading, MA, 1998.[Lak96] John Lakos. Large-Scale C++ Software Design. Addison Wesley Longman, Reading, MA,1996.[LH89] Karl J. Lieberherr and Ian Holland. Assuring good style for object-oriented programs. IEEE Software, pages 3848, September 1989.[Lis88] Barbara Liskov. Data abstraction and hierarchy. SIGPLAN Notices, 23(5), May 1988.[LMB92] John R. Levine, Tony Mason and Doug Brown. Lex and Yacc. O'Reilly & Associates, Inc.,Sebastopol, CA, second edition, 1992.[McC95] Jim McCarthy. Dynamics of Software Development. Microsoft Press, Redmond, WA, 1995.[Mey96] Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs.Addison-Wesley, Reading, MA, 1996.[Mey97a] Scott Meyers. Effective C++: 50 Specific Ways to Improve Your Programs and Designs.Addison Wesley Longman, Reading, MA, second edition, 1997. [Mey97b] Bertrand Meyer. Object-Oriented Software Construction. Prentice Hall, Englewood Cliffs, NJ,second edition, 1997.[Pet98] Charles Petzold. Programming Windows, The Definitive Guide to the Win32 API. MicrosoftPress, Redmond, WA, fifth edition, 1998.[Sch95] Bruce Schneier. Applied Cryptography: Protocols, Algorithms, and Source Code in C. JohnWiley & Sons, New York, NY, second edition, 1995.[Sed83] Robert Sedgewick. Algorithms. Addison-Wesley, Reading, MA, 1983.[Sed92] Robert Sedgewick. Algorithms in C++. Addison-Wesley, Reading, MA, 1992.[SF96] Robert Sedgewick and Phillipe Flajolet. An Introduction to the Analysis of Algorithms.Addison-Wesley, Reading, MA, 1996.[Ste92] W. Richard Stevens. Advanced Programming in the Unix Environment. Addison-Wesley,Reading, MA, 1992.[Ste98] W. Richard Stevens. Unix Network Programming, Volume 1: Networking APIs: Sockets and Xti. Prentice Hall, Englewood Cliffs, NJ, second edition, 1998.[Ste99] W. Richard Stevens. Unix Network Programming, Volume 2: Interprocess Communications.Prentice Hall, Englewood Cliffs, NJ, second edition, 1999.[Str35] James Ridley Stroop. Studies of interference in serial verbal reactions. Journal of Experimental Psychology, 18:643662, 1935.[WK82] James Q. Wilson and George Kelling. The police and neighborhood safety. The Atlantic Monthly, 249(3):2938, March 1982.[YC86] Edward Yourdon and Larry L. Constantine. Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design. Prentice Hall, Englewood Cliffs, NJ, second edition, 1986.[You95] Edward Yourdon. Managing projects to produce good-enough software. IEEE Software,March 1995.I l@ve RuBoard    I l@ve RuBoard   Appendix B. Answers to ExercisesExercise 1:from Orthogonality You are writing a class called Split, which splits input lines into fields. Which of the following two Java class signatures is the more orthogonal design?                                                   class Splitl {     public Splitl(InputStreamReader rdr) { ...     public void readNextLine() throws IOException { ...     public int numFields() { ...     public String getField(int fieldNo) { ...   }   class Split2 {     public Split2(String line) { ...     public int numFields() { ...     public String getField(int fieldNo) { ...   } Answer 1:To our way of thinking, class  Split2  is more orthogonal. It concentrates on its own task, splitting  lines, and ignores details such as where the lines are coming from. Not only does this make the  code easier to develop, but it also makes it more flexible.  Split2  can split lines read from a file,  generated by another routine, or passed in via the environment  .Exercise 2:from Orthogonality Which will lead to a more orthogonal design: modeless or modal dialog boxes? Answer 2:If done correctly, probably modeless. A system that uses modeless dialog boxes will be less concerned with what is going on at any particular moment in time. It will likely have a better intermodule communications infrastructure than a modal system, which may have built-in assumptions about the state of the system?assumptions that lead to increased coupling and decreased orthogonality .      N 1  # then north 1    E 2  # then east 2    S 1  # then back south    U    # pen up                                                Implement the code that parses this language. It should be designed so that it is simple to add new commands.     over a communications line.Exercise 10:from Estimating So, which has the higher bandwidth? Answer 10:Subject to the caveats in  Answer 9 : A 4GB tape contains 32 × 109 bits, so a 1Mbps line would have to pump data for about 32,000 seconds, or roughly 9 hours, to transfer the equivalent amount of information. If the person is walking at a constant 3½ mph, then ourtwo machines would need to be at least 31 miles apart for the communications line to outperform our courier. Otherwise, the person wins .       Exercise 17:from Design by Contract The classic examples of DEC (as in Exercises 1416) show an implementation of an ADT(Abstract Data Type)typically a stack or queue. But not many people really write thesekinds of low-level classes.So, for this exercise, design an interface to a kitchen blender. It will eventually be a Web-based, Internet-enabled, CORBA-fled blender, but for now we just need the interface to control it. It has ten speed settings (0 means off). You can't operate it empty, and you can change the speed only one unit at a time (that is, from 0 to 1, and from 1 to 2, not from 0 to 2).Here are the methods. Add appropriate pre- and postconditions and an invariant.                                                   int getSpeed()   void setSpeed(int x)   boolean isFull()   void fill()   void empty() Answer 17:We'll show the function signatures in Java, with the pre- and postconditions labeled as in iContract .First, the invariant for the class:                                                    /**      * @invariant getSpeed() > 0      *      implies isFull()              // Don't run empty      * @invariant getSpeed() >= 0 &&      *      getSpeed() < 10               // Range check      */                                                Next, the pre- and postconditions:                                                    /**      * @pre Math.abs(getSpeed() - x) <= 1 // Only change by one      * @pre x >= 0 && x < 10            // Range check      * @post getSpeed() == x            // Honor requested speed      */    public void setSpeed(final int x)    /**      * @pre !isFull()                     // Don't fill it twice       * @post isFull()                     // Ensure it was done      */    void fill()    /**      * @pre isFull()                      // Don't empty it twice      * @post !isFull()                  // Ensure it was done      */    void empty()Exercise 18:from Design by Contract How many numbers are in the series 0,5,10,15,, 100? Answer 18:There are 21 terms in the series. If you said 20, you just experienced a fencepost error .Exercise 19:from Assertive Programming A quick reality check. Which of these "impossible" things can happen?A month with fewer than 28 days1.stat("." ,&sb) == -1 (that is, can't access the current directory)2.In C++: a=2;b=3; if (a+b!=5) exit(l);3.A triangle with an interior angle sum ? 180°4.A minute that doesn't have 60 seconds5.In Java: (a + 1) <= a6. Answer 19:September, 1752 had only 19 days. This was done to synchronize calendars as part of the Gregorian Reformation.1.The directory could have been removed by another process, you might not havepermission to read it, &sb might be invalidyou get the picture.2.We sneakily didn't specify the types of a and b. Operator overloading might have defined +, =, or ! = to have unexpected behavior. Also, a and b may be aliases for the same variable, so the second assignment will overwrite the value stored in the first.3. In non-Euclidean geometry, the sum of the angles of a triangle will not add up to180°. Think of a triangle mapped on the surface of a sphere.4.Leap minutes may have 61 or 62 seconds.5.Overflow may leave the result of a + 1 negative (this can also happen in C and C++).6.Exercise 20:from Assertive Programming Develop a simple assertion checking class for Java.  How should each be handled? Should an error be generated, should an exception be raised, or should the condition be ignored? Answer 21:Running out of memory is an exceptional condition, so we feel that case (1) should raise an  exception .Failure to find an entry is probably quite a normal occurrence. The application that calls ourcollection class may well write code that checks to see if an entry is present before adding a potential duplicate. We feel that case (2) should just return an error.Case (3) is more problematicif the value null is significant to the application, then it may be justifiably added to the container. If, however, it makes no sense to store null values, anexception should probably be thrown.Exercise 22:from How to Balance Resources Some C and C++ developers make a point of setting a pointer to NULL after they deallocate the memory it references. Why is this a good idea? Answer 22:In most C and C++ implementations, there is no way of checking that a pointer actually points to  valid memory. A common mistake is to deallocate a block of memory and reference that memory  later in the program. By then, the memory pointed to may well have been reallocated to some  other purpose. By setting the pointer to  NULL,  the programmers hope to prevent these rogue references?in most cases, dereferencing a NULL pointer will generate a runtime error  .Exercise 23:from How to Balance Resources Some Java developers make a point of setting an object variable to NULL after they have finished using the object. Why is this a good idea? Answer 23:By setting the reference to  NULL,  you reduce the number of pointers to the referenced object by  one. Once this count reaches zero, the object is eligible for garbage collection. Setting the  references to  NULL  can be significant for long-running programs, where the programmers need to  ensure that memory utilization doesn't increase over time  .Exercise 24:from Decoupling and the Law of Demeter   Exercise 26:from Decoupling and the Law of Demeter This example is also in Java.                                                   public class Colada {     private Blender myBlender;private Vector myStuff;     public Colada() {       myBlender = new Blender();       myStuff = new Vector() ;     }     private void doSomething() {       myBlender.addlngredients(myStuff.elements());     }   } Answer 26:Since  Colada  creates and owns both  myBlender  and  myStuff,  the calls to  addIngredients  and  elements  are allowed  .Exercise 27:from Decoupling and the Law of Demeter This example is in C++.                                                   void processTransaction(BankAccount acct, int) {     Person *who;     Money amt;     amt.setValue(123.45);     acct.setBalance(amt);     who = acct .getOwner() ;     markWorkflow(who->name(), SET_BALANCE);   } Answer 27:In this case,  processTransaction  owns  amt ?it is created on the stack,  acct  is passed in, so both  setValue  and  setBalance  are allowed. But  processTransaction  does not own  who,  so the call  who->name()  is in violation. The Law of Demeter suggests replacing this line with                                                   markWorkflow(acct.name(), SET_BALANCE);  tables externally.Sample values and results for use in unit testing.   Most applications define thesevalues inline in the testing harness, but you can get better flexibility by moving thetest dataand the definition of the acceptable resultsout of the code itself.5.Exercise 29:from It's Just a View Suppose you have an airline reservation system that includes the concept of a flight:                                                   public interface Flight {     // .Return false if flight full.     public boolean addPassenger(Passenger p);     public void addToWaitList(Passenger p);     public int getFlightCapacity();     public int getNumPassengers();   }If you add a passenger to the wait list, they'll be put on the flight automatically when an opening becomes available.There's a massive reporting job that goes through looking for overbooked or full flights to suggest when additional flights might be scheduled. It works fine, but it takes hours to run.We'd like to have a little more flexibility in processing wait-list passengers, and we've got todo something about that big reportit takes too long to run. Use the ideas from this sectionto redesign this interface. Answer 29:We'll take  Flight  and add some additional methods for maintaining two lists of listeners: one for  wait-list notification, and the other for full-flight notification  .                                                   public interface Passenger {     public void waitListAvailable();   }   public interface Flight {     ...     public void addWaitListListener(Passenger p);     public void removeWaitListListener(Passenger p);     public void addFullListener(FullListener b);     public void removeFullListener(FullListener b);     ...     }   public interface BigReport extends FullListener {     public void FlightFullAlert(Flight f);   }If we try to add a Passenger and fail because the flight is full, we can, optionally, put the Passenger on the wait list. When a spot opens up, waitList-Available will be called. This method can then choose to add the Passenger automatically, or have a service representative call the customer to ask if they are still interested, or whatever. We now havethe flexibility to perform different behaviors on a per-customer basis.Next, we want to avoid having the BigReport troll through tons of records looking for full flights. By having BigReport registered as a listener on Flights, each individual Flight canreport when it is fullor nearly full, if we want. Now users can get live, up-to-the-minutereports from BigReport instantly, without waiting hours for it to run as it did previously.Exercise 30:from Blackboards For each of the following applications, would a blackboard system be appropriate or not? Why?Image processing.   You'd like to have a number of parallel processes grab chunksof an image, process them, and put the completed chunk back.1.Group calendaring.   You've got people scattered across the globe, in different timezones, and speaking different languages, trying to schedule a meeting.2.Network monitoring tool.   The system gathers performance statistics and collectstrouble reports. You'd like to implement some agents to use this information to look for trouble in the system.3. Answer 30:Image processing.   For simple scheduling of a workload among the parallelprocesses, a shared work queue may be more than adequate. You might want toconsider a blackboard system if there is feedback involvedthat is, if the results ofone processed chunk affect other chunks, as in machine vision applications, orcomplex 3D image-warp transforms.1.Group calendaring.   This might be a good fit. You can post scheduled meetingsand availability to the blackboard. You have entities functioning autonomously, feedback from decisions is important, and participants may come and go.You might want to consider partitioning this kind of blackboard system depending onwho is searching: junior staff may care about only the immediate office, human resources may want only English-speaking offices worldwide, and the CEO may want the whole enchilada. There is also some flexibility on data formats: we are free 2.   If you find that your results don't follow a smooth curve, you might want to check to see ifsome other activity is using some of your processor's power. You probably won't get good figures on a multiuser system, and even if you are the only user you may find that background processes periodically take cycles away from your programs. You might also want to check memory: if the application starts using swap space, performance will nose dive.It is interesting to experiment with different compilers and different optimization settings. Wefound some that pretty startling speed-ups were possible by enabling aggressive optimization. We also found that on the wider RISC architectures the manufacturer's compilers often outperformed the more portable GCC. Presumably, the manufacturer is privy to the secrets of efficient code generation on these machines.Exercise 35:from Algorithm Speed The routine below prints out the contents of a binary tree. Assuming the tree is balanced, roughly how much stack space will the routine use while printing a tree of 1,000,000 elements? (Assume that subroutine calls impose no significant stack overhead.)                                                   void printTree(const Node *node) {     char buffer[1000];     if (node) {       printTree(node->left);        getNodeAsString(node, buffer);        puts(buffer);        printTree(node->right);     }   } Answer 35:The  printTree  routine uses about 1,000 bytes of stack space for the  buffer  variable. It calls itself  recursively to descend through the tree, and each nested call adds another 1,000 bytes to the  stack. It also calls itself when it gets to the leaf nodes, but exits immediately when it discovers that  the pointer passed in is  NULL.  If the depth of the tree is  D,  the maximum stack requirement is  therefore roughly 1000 x  (D +  1)  .A balanced binary tree holds twice as many elements at each level. A tree of depth D holds1 + 2+4+8 +  + 2D1), or 2D1, elements. Our million-element tree will therefore need | lg(l,000,001) |, or 20 levels.We'd therefore expect our routine to use roughly 21,000 bytes of stack. Exercise 36:from Algorithm Speed Can you see any way to reduce the stack requirements of the routine in Exercise 35 (apart from reducing the size of the buffer)? Answer 36:A couple of optimizations come to mind. First, the  printTree  routine calls itself on leaf nodes, only  to exit because there are no children. That call increases the maximum stack depth by about 1,000  bytes. We can also eliminate the tail recursion (the second recursive call), although this won't affect  the worst-case stack usage  .                                                   while (node) {     if (node->left) printTree(node->left);     getNodeAsString(node, buffer);     puts(buffer);     node = node->right;   }The biggest gain, however, comes from allocating just a single buffer, shared by allinvocations of printTree. Pass this buffer as a parameter to the recursive calls, and only 1,000 bytes will be allocated, regardless of the depth of recursion.                                                   void printTreePrivate(const Node *node, char *buffer) {     if (node) {        printTreePrivate(node->left, buffer);        getNodeAsString(node, buffer);        puts(buffer);        printTreePrivate(node->right, buffer);     }   }   void newPrintTree(const Node *node) {     char buffer[1000];     printTreePrivate(node, buffer);   }Exercise 37:from Algorithm Speed On page 180, we claimed that a binary chop is O(lg(n)). Can you prove this? Answer 37:There are a couple of ways of getting there. One is to turn the problem on its head. If the array has   just one element, we don't iterate around the loop. Each additional iteration doubles the size of the  array we can search. The general formula for the array size is therefore  n  = 2 m ,  where  m  is the  number of iterations. If you take logs to the base 2 of each side, you get lg( n ) = lg(2 m ), which by the  definition of logs becomes lg( n ) =  m. Exercise 38:from Refactoring The following code has obviously been updated several times over the years, but the changes haven't improved its structure. Refactor it.                                                   if (state == TEXAS) {     rate = TX_RATE;     amt = base * TX_RATE;     calc = 2*basis(amt) + extra(amt)*1.05;   }   else if ((state == OHIO) || (state == MAINE)) {     rate = (state == OHIO) ? OH_RATE : MN_RATE;     amt = base * rate;     calc = 2*basis(amt) + extra(amt)*1.05;     if (state == OHIO)        points = 2;   }   else {     rate = 1;     amt = base;     calc = 2*basis(amt) + extra(amt)*1.05;   } Answer 38:We might suggest a fairly mild restructuring here: make sure that every test is performed just once,  and make all the calculations common. If the expression  2*basis(. . . ) * 1.05  appears in other  places in the program, we should probably make it a function. We haven't bothered here  .We've added a rate_lookup array, initialized so that entries other than Texas, Ohio, and Maine have a value of 1. This approach makes it easy to add values for other states in the future. Depending on the expected usage pattern, we might want to make the points field an array lookup as well.                                                   rate = rate_lookup[state];   amt = base * rate;   calc = 2*basis(amt) + extra(amt)*1.05;   if (state == OHIO)      points = 2;Exercise 39:from Refactoring The following Java class needs to support a few more shapes. Refactor the class to prepare it for the additions.                                                   public class Shape {     public static final int SQUARE = 1;     public static final int CIRCLE = 2;     public static final int RIGHT_TRIANGLE = 3;     private int   shapeType;     private double size;     public Shape(int shapeType, double size) {       this.shapeType = shapeType;       this.size = size;     }     // ... other methods ...     public double area() {       switch (shapeType) {       case SQUARE:    return size*size;       case CIRCLE:    return Math.PI*size*size/4.0;       case RIGHT_TRIANGLE: return size*size/2.0;       }       return 0;     }   } Answer 39:When you see someone using enumerated types (or their equivalent in Java) to distinguish  between variants of a type, you can often improve the code by subclassing :                                                   public class Shape {     private double size;     public Shape(double size) {       this.size = size;     }     public double getSize() { return size; }   }    public class Square extends Shape {     public Square(double size) {       super(size);     }     public double area() {       double size = getSize() ;       return size*size;     }   }   public class Circle extends Shape {     public Circle(double size) {       super(size);     }     public double area() {       double size = getSize();       return Math.PI*size*size/4.0;     }   }   // etc...Exercise 40:from Refactoring This Java code is part of a framework that will be used throughout your project. Refactor it to be more general and easier to extend in the future.                                                   public class Window {     public Window(int width, int height) { ... }     public void setSize(int width, int height) { ... }     public boolean overlaps(Window w) { ... }     public int getArea() { . . . }   } Answer 40:This case is interesting. At first sight, it seems reasonable that a window should have a width and a  height. However, consider the future. Let's imagine that we want to support arbitrarily shaped  windows (which will be difficult if the  Window  class knows all about rectangles and their properties) .We'd suggest abstracting the shape of the window out of the Window class itself.                                                   public abstract class Shape {     // ...      public abstract boolean overlaps(Shape s);     public abstract int getArea();   }   public class Window {     private Shape shape;     public Window(Shape shape) {       this.shape = shape;       ...     }     public void setShape(Shape shape) {       this.shape = shape;       ...     }     public boolean overlaps(Window w) {       return shape.overlaps(w.shape);     }     public int getArea() {       return shape.getArea();     }   }Note that in this approach we've used delegation rather than subclassing: a window is not a"kind-of'' shapea window "has-a" shape. It uses a shape to do its job. You'll often finddelegation useful when refactoring.We could also have extended this example by introducing a Java interface that specifiedthe methods a class must support to support the shape functions. This is a good idea. It means that when you extend the concept of a shape, the compiler will warn you about classes that you have affected. We recommend using interfaces this way when you delegate all the functions of some other class.Exercise 41:from Code That's Easy to Test Design a test jig for the blender interface described in the answer to Exercise 17. Write a shell script that will perform a regression test for the blender. You need to test basic functionality, error and boundary conditions, and any contractual obligations. What restrictions are placed on changing the speed? Are they being honored? Answer 41:First, we'll add a  main  to act  as a  unit test driver. It will accept a very small, simple language as an  argument: "E" to empty the blender, "F" to fill it, digits 0-9 to set the speed, and so on  .    This statement is probably a hard requirement. 5.I l@ve RuBoard    